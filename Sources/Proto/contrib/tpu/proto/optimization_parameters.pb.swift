// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/contrib/tpu/proto/optimization_parameters.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Tensorflow_Tpu_ClippingLimits {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// -inf if not set
  public var lower: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _storage._lower ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_uniqueStorage()._lower = newValue}
  }
  /// Returns true if `lower` has been explicitly set.
  public var hasLower: Bool {return _storage._lower != nil}
  /// Clears the value of `lower`. Subsequent reads from it will return its default value.
  public mutating func clearLower() {_uniqueStorage()._lower = nil}

  /// +inf if not set
  public var upper: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _storage._upper ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_uniqueStorage()._upper = newValue}
  }
  /// Returns true if `upper` has been explicitly set.
  public var hasUpper: Bool {return _storage._upper != nil}
  /// Clears the value of `upper`. Subsequent reads from it will return its default value.
  public mutating func clearUpper() {_uniqueStorage()._upper = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Dynamic learning rate specification in the TPUEmbeddingConfiguration. The
/// actual learning rates are provided as a scalar input list to the
/// SendTPUEmbeddingGradients Op indexed by their tag specified through the
/// following proto.
public struct Tensorflow_Tpu_DynamicLearningRate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// For tables where learning rates are dynamically computed and communicated
  /// to the TPU embedding program, a tag must be specified for the learning
  /// rate.
  ///
  /// The tag must be a non-negative  integer. The total number of unique tags
  /// must be less than or equal to the number of tables in the TPU embedding
  /// configuration (a table does not specify any tag if it uses a constant
  /// learning rate, and specifies exactly one tag if it uses dynamic learning
  /// rates).
  ///
  /// All tags in the range [0, number_of_unique_tags) must be present in the TPU
  /// embedding configuration, i.e. a tag cannot be skipped if a different tag
  /// numerically greater than it is used in the configuration.
  ///
  /// If multiple tables specify the same tag, they *MUST* have
  /// the same dynamic learning rate, for example, their dynamic learning rate
  /// could be computed by the same TensorFlow sub-graph. The partitioning of the
  /// embedding layer would be more optimal if the number_of_unique_tags is as
  /// *LOW* as possible, i.e., if many tables share the same tag.
  ///
  /// The learning_rate input of the SendTPUEmbeddingGradients op is used to
  /// communicate dynamic learning rates to the TPU embedding program.
  /// The learning_rate input is a list of scalars where the size of the list is
  /// equal to the number of unique tags. The learning rate associated with a
  /// particular tag is specified by populating its corresponding index in the
  /// list of learning_rate scalars.
  public var tag: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Source of learning rate to use.
public struct Tensorflow_Tpu_LearningRate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var learningRate: OneOf_LearningRate? {
    get {return _storage._learningRate}
    set {_uniqueStorage()._learningRate = newValue}
  }

  public var constant: Float {
    get {
      if case .constant(let v)? = _storage._learningRate {return v}
      return 0
    }
    set {_uniqueStorage()._learningRate = .constant(newValue)}
  }

  public var dynamic: Tensorflow_Tpu_DynamicLearningRate {
    get {
      if case .dynamic(let v)? = _storage._learningRate {return v}
      return Tensorflow_Tpu_DynamicLearningRate()
    }
    set {_uniqueStorage()._learningRate = .dynamic(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_LearningRate: Equatable {
    case constant(Float)
    case dynamic(Tensorflow_Tpu_DynamicLearningRate)

  #if !swift(>=4.1)
    public static func ==(lhs: Tensorflow_Tpu_LearningRate.OneOf_LearningRate, rhs: Tensorflow_Tpu_LearningRate.OneOf_LearningRate) -> Bool {
      switch (lhs, rhs) {
      case (.constant(let l), .constant(let r)): return l == r
      case (.dynamic(let l), .dynamic(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// https://www.tensorflow.org/api_docs/python/tf/train/AdagradOptimizer
/// https://github.com/tensorflow/tensorflow/blob/c19e29306ce1777456b2dbb3a14f511edf7883a8/tensorflow/core/kernels/training_ops.cc#L151
public struct Tensorflow_Tpu_AdagradParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var initialAccumulator: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://www.tensorflow.org/api_docs/python/tf/train/GradientDescentOptimizer
/// https://github.com/tensorflow/tensorflow/blob/c19e29306ce1777456b2dbb3a14f511edf7883a8/tensorflow/core/kernels/training_ops.cc#L423
public struct Tensorflow_Tpu_StochasticGradientDescentParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://www.tensorflow.org/api_docs/python/tf/train/FtrlOptimizer
/// https://github.com/tensorflow/tensorflow/blob/c19e29306ce1777456b2dbb3a14f511edf7883a8/tensorflow/core/kernels/training_ops.cc#L192
public struct Tensorflow_Tpu_FtrlParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var l1: Float = 0

  public var l2: Float = 0

  public var lrPower: Float = 0

  public var initialAccum: Float = 0

  public var initialLinear: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The Adam optimizer does not implement hyper-parameter update; use the dynamic
/// learning rate feature instead, setting the learning rate to:
/// user learning_rate * sqrt(1 - beta2^t) / (1 - beta1^t)
/// Here, t is the current timestep.
///
/// https://www.tensorflow.org/api_docs/python/tf/train/AdamOptimizer
/// https://github.com/tensorflow/tensorflow/blob/ab51450c817674c8ff08a7ae4f8ac50cdc4bed8b/tensorflow/python/training/adam.py#L54
///
/// Note that the code by default implements the lazy version of Adam
/// (https://www.tensorflow.org/api_docs/python/tf/contrib/opt/LazyAdamOptimizer)
/// unless the use_non_lazy_adam parameter is set, in which case it implements
/// the normal version of Adam that updates all parameters in the embedding
/// table, even for entries that are not used in the current minibatch
/// (https://www.tensorflow.org/api_docs/python/tf/contrib/opt/AdamOptimizer). If
/// use_non_lazy_adam is enabled, use_gradient_accumulation is also required in
/// order to get correct results; a warning will be printed otherwise (which may
/// change to an error in the future). If use_sum_inside_sqrt is set, the Adam
/// variable update formula will be changed from m / (sqrt(v) + epsilon) to
/// m / sqrt(v + epsilon**2); this option improves the performance of TPU
/// training and is not expected to harm model quality.
public struct Tensorflow_Tpu_AdamParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var beta1: Float = 0

  public var beta2: Float = 0

  public var epsilon: Float = 0

  public var initialM: Float = 0

  public var initialV: Float = 0

  public var useNonLazyAdam: Bool = false

  public var useSumInsideSqrt: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://www.tensorflow.org/api_docs/python/tf/train/MomentumOptimizer
/// https://github.com/tensorflow/tensorflow/blob/c19e29306ce1777456b2dbb3a14f511edf7883a8/tensorflow/core/kernels/training_ops.cc#L271
public struct Tensorflow_Tpu_MomentumParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var momentum: Float = 0

  public var useNesterov: Bool = false

  public var initialAccum: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://www.tensorflow.org/api_docs/python/tf/train/RMSPropOptimizer
/// https://github.com/tensorflow/tensorflow/blob/c19e29306ce1777456b2dbb3a14f511edf7883a8/tensorflow/core/kernels/training_ops.cc#L356
public struct Tensorflow_Tpu_RmsPropParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rho: Float = 0

  public var momentum: Float = 0

  public var epsilon: Float = 0

  public var initialMs: Float = 0

  public var initialMom: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://www.tensorflow.org/api_docs/python/tf/train/RMSPropOptimizer
/// https://github.com/tensorflow/tensorflow/blob/c19e29306ce1777456b2dbb3a14f511edf7883a8/tensorflow/core/kernels/training_ops.cc#L372
public struct Tensorflow_Tpu_CenteredRmsPropParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rho: Float = 0

  public var momentum: Float = 0

  public var epsilon: Float = 0

  public var initialMs: Float = 0

  public var initialMom: Float = 0

  public var initialMg: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Variant of algorithm in http://proceedings.mlr.press/v44/shamir15.pdf
public struct Tensorflow_Tpu_MdlAdagradLightParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var l2: Float = 0

  public var lrPower: Float = 0

  public var minServableMdlBenefit: Float = 0

  public var mdlMixInMargin: Float = 0

  public var mdlBenefitRampupCoeff: Float = 0

  public var mdlMinWeight: Float = 0

  public var benefitRevisitScale: Float = 0

  public var maxEventBenefit: Float = 0

  public var maxTotalBenefit: Float = 0

  public var mdlHardLimit: Float = 0

  public var hardLimitMinBenefit: Bool = false

  public var mdlRegularize: Bool = false

  public var initialAccumulator: Float = 0

  public var initialWeight: Float = 0

  public var initialBenefit: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://www.tensorflow.org/api_docs/python/tf/train/RMSPropOptimizer
/// https://github.com/tensorflow/tensorflow/blob/c19e29306ce1777456b2dbb3a14f511edf7883a8/tensorflow/core/kernels/training_ops.cc#L68
public struct Tensorflow_Tpu_AdadeltaParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rho: Float = 0

  public var epsilon: Float = 0

  public var initialAccumulator: Float = 0

  public var initialUpdate: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// https://www.tensorflow.org/api_docs/python/tf/train/RMSPropOptimizer
/// https://github.com/tensorflow/tensorflow/blob/c19e29306ce1777456b2dbb3a14f511edf7883a8/tensorflow/core/kernels/training_ops.cc#L164
public struct Tensorflow_Tpu_ProximalAdagradParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var l1: Float = 0

  public var l2: Float = 0

  public var initialAccumulator: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tensorflow_Tpu_OptimizationParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Learning rate used for updating the embedding layer parameters.
  public var learningRate: Tensorflow_Tpu_LearningRate {
    get {return _storage._learningRate ?? Tensorflow_Tpu_LearningRate()}
    set {_uniqueStorage()._learningRate = newValue}
  }
  /// Returns true if `learningRate` has been explicitly set.
  public var hasLearningRate: Bool {return _storage._learningRate != nil}
  /// Clears the value of `learningRate`. Subsequent reads from it will return its default value.
  public mutating func clearLearningRate() {_uniqueStorage()._learningRate = nil}

  /// Limits to which to clip the weight values after the backward pass; not
  /// present means no limits are applied.
  public var clippingLimits: Tensorflow_Tpu_ClippingLimits {
    get {return _storage._clippingLimits ?? Tensorflow_Tpu_ClippingLimits()}
    set {_uniqueStorage()._clippingLimits = newValue}
  }
  /// Returns true if `clippingLimits` has been explicitly set.
  public var hasClippingLimits: Bool {return _storage._clippingLimits != nil}
  /// Clears the value of `clippingLimits`. Subsequent reads from it will return its default value.
  public mutating func clearClippingLimits() {_uniqueStorage()._clippingLimits = nil}

  /// Limits to which to clip the backward pass gradient before using it for
  /// updates; not present means no limits are applied.
  public var gradientClippingLimits: Tensorflow_Tpu_ClippingLimits {
    get {return _storage._gradientClippingLimits ?? Tensorflow_Tpu_ClippingLimits()}
    set {_uniqueStorage()._gradientClippingLimits = newValue}
  }
  /// Returns true if `gradientClippingLimits` has been explicitly set.
  public var hasGradientClippingLimits: Bool {return _storage._gradientClippingLimits != nil}
  /// Clears the value of `gradientClippingLimits`. Subsequent reads from it will return its default value.
  public mutating func clearGradientClippingLimits() {_uniqueStorage()._gradientClippingLimits = nil}

  /// Amount of weight decay to apply; see weight_decay_optimizers.py for
  /// details. Almost all optimizers are supported with this option (MDL Adagrad
  /// Light does not work, and SGD does not behave as expected if it is enabled).
  /// Although there is no check, users who want weight decay will probably also
  /// want to enable gradient accumulation as well so that the decay will happen
  /// once per minibatch.
  public var weightDecayFactor: Float {
    get {return _storage._weightDecayFactor}
    set {_uniqueStorage()._weightDecayFactor = newValue}
  }

  /// Whether to use gradient accumulation (do two passes over the input
  /// gradients: one to accumulate them into a temporary array and another to
  /// apply them using the actual optimization algorithm). This feature is
  /// experimental -- it has not been fully verified and may cause training
  /// crashes and/or failures.
  public var useGradientAccumulation: Bool {
    get {return _storage._useGradientAccumulation}
    set {_uniqueStorage()._useGradientAccumulation = newValue}
  }

  /// Optimization algorithm parameters; which field is selected determines which
  /// algorithm to use.
  public var parameters: OneOf_Parameters? {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  public var adagrad: Tensorflow_Tpu_AdagradParameters {
    get {
      if case .adagrad(let v)? = _storage._parameters {return v}
      return Tensorflow_Tpu_AdagradParameters()
    }
    set {_uniqueStorage()._parameters = .adagrad(newValue)}
  }

  public var stochasticGradientDescent: Tensorflow_Tpu_StochasticGradientDescentParameters {
    get {
      if case .stochasticGradientDescent(let v)? = _storage._parameters {return v}
      return Tensorflow_Tpu_StochasticGradientDescentParameters()
    }
    set {_uniqueStorage()._parameters = .stochasticGradientDescent(newValue)}
  }

  public var ftrl: Tensorflow_Tpu_FtrlParameters {
    get {
      if case .ftrl(let v)? = _storage._parameters {return v}
      return Tensorflow_Tpu_FtrlParameters()
    }
    set {_uniqueStorage()._parameters = .ftrl(newValue)}
  }

  public var adam: Tensorflow_Tpu_AdamParameters {
    get {
      if case .adam(let v)? = _storage._parameters {return v}
      return Tensorflow_Tpu_AdamParameters()
    }
    set {_uniqueStorage()._parameters = .adam(newValue)}
  }

  public var momentum: Tensorflow_Tpu_MomentumParameters {
    get {
      if case .momentum(let v)? = _storage._parameters {return v}
      return Tensorflow_Tpu_MomentumParameters()
    }
    set {_uniqueStorage()._parameters = .momentum(newValue)}
  }

  public var rmsProp: Tensorflow_Tpu_RmsPropParameters {
    get {
      if case .rmsProp(let v)? = _storage._parameters {return v}
      return Tensorflow_Tpu_RmsPropParameters()
    }
    set {_uniqueStorage()._parameters = .rmsProp(newValue)}
  }

  public var centeredRmsProp: Tensorflow_Tpu_CenteredRmsPropParameters {
    get {
      if case .centeredRmsProp(let v)? = _storage._parameters {return v}
      return Tensorflow_Tpu_CenteredRmsPropParameters()
    }
    set {_uniqueStorage()._parameters = .centeredRmsProp(newValue)}
  }

  public var mdlAdagradLight: Tensorflow_Tpu_MdlAdagradLightParameters {
    get {
      if case .mdlAdagradLight(let v)? = _storage._parameters {return v}
      return Tensorflow_Tpu_MdlAdagradLightParameters()
    }
    set {_uniqueStorage()._parameters = .mdlAdagradLight(newValue)}
  }

  public var adadelta: Tensorflow_Tpu_AdadeltaParameters {
    get {
      if case .adadelta(let v)? = _storage._parameters {return v}
      return Tensorflow_Tpu_AdadeltaParameters()
    }
    set {_uniqueStorage()._parameters = .adadelta(newValue)}
  }

  public var proximalAdagrad: Tensorflow_Tpu_ProximalAdagradParameters {
    get {
      if case .proximalAdagrad(let v)? = _storage._parameters {return v}
      return Tensorflow_Tpu_ProximalAdagradParameters()
    }
    set {_uniqueStorage()._parameters = .proximalAdagrad(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Optimization algorithm parameters; which field is selected determines which
  /// algorithm to use.
  public enum OneOf_Parameters: Equatable {
    case adagrad(Tensorflow_Tpu_AdagradParameters)
    case stochasticGradientDescent(Tensorflow_Tpu_StochasticGradientDescentParameters)
    case ftrl(Tensorflow_Tpu_FtrlParameters)
    case adam(Tensorflow_Tpu_AdamParameters)
    case momentum(Tensorflow_Tpu_MomentumParameters)
    case rmsProp(Tensorflow_Tpu_RmsPropParameters)
    case centeredRmsProp(Tensorflow_Tpu_CenteredRmsPropParameters)
    case mdlAdagradLight(Tensorflow_Tpu_MdlAdagradLightParameters)
    case adadelta(Tensorflow_Tpu_AdadeltaParameters)
    case proximalAdagrad(Tensorflow_Tpu_ProximalAdagradParameters)

  #if !swift(>=4.1)
    public static func ==(lhs: Tensorflow_Tpu_OptimizationParameters.OneOf_Parameters, rhs: Tensorflow_Tpu_OptimizationParameters.OneOf_Parameters) -> Bool {
      switch (lhs, rhs) {
      case (.adagrad(let l), .adagrad(let r)): return l == r
      case (.stochasticGradientDescent(let l), .stochasticGradientDescent(let r)): return l == r
      case (.ftrl(let l), .ftrl(let r)): return l == r
      case (.adam(let l), .adam(let r)): return l == r
      case (.momentum(let l), .momentum(let r)): return l == r
      case (.rmsProp(let l), .rmsProp(let r)): return l == r
      case (.centeredRmsProp(let l), .centeredRmsProp(let r)): return l == r
      case (.mdlAdagradLight(let l), .mdlAdagradLight(let r)): return l == r
      case (.adadelta(let l), .adadelta(let r)): return l == r
      case (.proximalAdagrad(let l), .proximalAdagrad(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specification of an optimization algorithm's state variables (both the main
/// value vector and any extra accumulators, etc.).
public struct Tensorflow_Tpu_StateVariableSpecification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parameter name for the state variable.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Usage type of this state variable.
  public var usage: OneOf_Usage? {
    get {return _storage._usage}
    set {_uniqueStorage()._usage = newValue}
  }

  public var userDefined: Tensorflow_Tpu_StateVariableSpecification.UserDefined {
    get {
      if case .userDefined(let v)? = _storage._usage {return v}
      return Tensorflow_Tpu_StateVariableSpecification.UserDefined()
    }
    set {_uniqueStorage()._usage = .userDefined(newValue)}
  }

  public var fillWithConstant: Tensorflow_Tpu_StateVariableSpecification.FillWithConstant {
    get {
      if case .fillWithConstant(let v)? = _storage._usage {return v}
      return Tensorflow_Tpu_StateVariableSpecification.FillWithConstant()
    }
    set {_uniqueStorage()._usage = .fillWithConstant(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Usage type of this state variable.
  public enum OneOf_Usage: Equatable {
    case userDefined(Tensorflow_Tpu_StateVariableSpecification.UserDefined)
    case fillWithConstant(Tensorflow_Tpu_StateVariableSpecification.FillWithConstant)

  #if !swift(>=4.1)
    public static func ==(lhs: Tensorflow_Tpu_StateVariableSpecification.OneOf_Usage, rhs: Tensorflow_Tpu_StateVariableSpecification.OneOf_Usage) -> Bool {
      switch (lhs, rhs) {
      case (.userDefined(let l), .userDefined(let r)): return l == r
      case (.fillWithConstant(let l), .fillWithConstant(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// A normal state variable that should be saved and restored in checkpoints
  /// and used as an input or output to non-debug TensorFlow ops.
  public struct UserDefined {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A state variable that should be filled with a constant and normally hidden
  /// from users (used for intermediate gradients being accumulated, for
  /// example).
  public struct FillWithConstant {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var initialValue: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorflow.tpu"

extension Tensorflow_Tpu_ClippingLimits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClippingLimits"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lower"),
    2: .same(proto: "upper"),
  ]

  fileprivate class _StorageClass {
    var _lower: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
    var _upper: SwiftProtobuf.Google_Protobuf_FloatValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _lower = source._lower
      _upper = source._upper
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._lower)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._upper)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._lower {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._upper {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_ClippingLimits, rhs: Tensorflow_Tpu_ClippingLimits) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._lower != rhs_storage._lower {return false}
        if _storage._upper != rhs_storage._upper {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_DynamicLearningRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DynamicLearningRate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.tag)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tag != 0 {
      try visitor.visitSingularInt32Field(value: self.tag, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_DynamicLearningRate, rhs: Tensorflow_Tpu_DynamicLearningRate) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_LearningRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LearningRate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "constant"),
    2: .same(proto: "dynamic"),
  ]

  fileprivate class _StorageClass {
    var _learningRate: Tensorflow_Tpu_LearningRate.OneOf_LearningRate?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _learningRate = source._learningRate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._learningRate != nil {try decoder.handleConflictingOneOf()}
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {_storage._learningRate = .constant(v)}
        case 2:
          var v: Tensorflow_Tpu_DynamicLearningRate?
          if let current = _storage._learningRate {
            try decoder.handleConflictingOneOf()
            if case .dynamic(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._learningRate = .dynamic(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._learningRate {
      case .constant(let v)?:
        try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
      case .dynamic(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_LearningRate, rhs: Tensorflow_Tpu_LearningRate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._learningRate != rhs_storage._learningRate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_AdagradParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdagradParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initial_accumulator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.initialAccumulator)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.initialAccumulator != 0 {
      try visitor.visitSingularFloatField(value: self.initialAccumulator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_AdagradParameters, rhs: Tensorflow_Tpu_AdagradParameters) -> Bool {
    if lhs.initialAccumulator != rhs.initialAccumulator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_StochasticGradientDescentParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StochasticGradientDescentParameters"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_StochasticGradientDescentParameters, rhs: Tensorflow_Tpu_StochasticGradientDescentParameters) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_FtrlParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FtrlParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "l1"),
    2: .same(proto: "l2"),
    3: .standard(proto: "lr_power"),
    4: .standard(proto: "initial_accum"),
    5: .standard(proto: "initial_linear"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.l1)
      case 2: try decoder.decodeSingularFloatField(value: &self.l2)
      case 3: try decoder.decodeSingularFloatField(value: &self.lrPower)
      case 4: try decoder.decodeSingularFloatField(value: &self.initialAccum)
      case 5: try decoder.decodeSingularFloatField(value: &self.initialLinear)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.l1 != 0 {
      try visitor.visitSingularFloatField(value: self.l1, fieldNumber: 1)
    }
    if self.l2 != 0 {
      try visitor.visitSingularFloatField(value: self.l2, fieldNumber: 2)
    }
    if self.lrPower != 0 {
      try visitor.visitSingularFloatField(value: self.lrPower, fieldNumber: 3)
    }
    if self.initialAccum != 0 {
      try visitor.visitSingularFloatField(value: self.initialAccum, fieldNumber: 4)
    }
    if self.initialLinear != 0 {
      try visitor.visitSingularFloatField(value: self.initialLinear, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_FtrlParameters, rhs: Tensorflow_Tpu_FtrlParameters) -> Bool {
    if lhs.l1 != rhs.l1 {return false}
    if lhs.l2 != rhs.l2 {return false}
    if lhs.lrPower != rhs.lrPower {return false}
    if lhs.initialAccum != rhs.initialAccum {return false}
    if lhs.initialLinear != rhs.initialLinear {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_AdamParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdamParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "beta1"),
    4: .same(proto: "beta2"),
    5: .same(proto: "epsilon"),
    6: .standard(proto: "initial_m"),
    7: .standard(proto: "initial_v"),
    8: .standard(proto: "use_non_lazy_adam"),
    10: .standard(proto: "use_sum_inside_sqrt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3: try decoder.decodeSingularFloatField(value: &self.beta1)
      case 4: try decoder.decodeSingularFloatField(value: &self.beta2)
      case 5: try decoder.decodeSingularFloatField(value: &self.epsilon)
      case 6: try decoder.decodeSingularFloatField(value: &self.initialM)
      case 7: try decoder.decodeSingularFloatField(value: &self.initialV)
      case 8: try decoder.decodeSingularBoolField(value: &self.useNonLazyAdam)
      case 10: try decoder.decodeSingularBoolField(value: &self.useSumInsideSqrt)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.beta1 != 0 {
      try visitor.visitSingularFloatField(value: self.beta1, fieldNumber: 3)
    }
    if self.beta2 != 0 {
      try visitor.visitSingularFloatField(value: self.beta2, fieldNumber: 4)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 5)
    }
    if self.initialM != 0 {
      try visitor.visitSingularFloatField(value: self.initialM, fieldNumber: 6)
    }
    if self.initialV != 0 {
      try visitor.visitSingularFloatField(value: self.initialV, fieldNumber: 7)
    }
    if self.useNonLazyAdam != false {
      try visitor.visitSingularBoolField(value: self.useNonLazyAdam, fieldNumber: 8)
    }
    if self.useSumInsideSqrt != false {
      try visitor.visitSingularBoolField(value: self.useSumInsideSqrt, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_AdamParameters, rhs: Tensorflow_Tpu_AdamParameters) -> Bool {
    if lhs.beta1 != rhs.beta1 {return false}
    if lhs.beta2 != rhs.beta2 {return false}
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.initialM != rhs.initialM {return false}
    if lhs.initialV != rhs.initialV {return false}
    if lhs.useNonLazyAdam != rhs.useNonLazyAdam {return false}
    if lhs.useSumInsideSqrt != rhs.useSumInsideSqrt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_MomentumParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentumParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentum"),
    2: .standard(proto: "use_nesterov"),
    3: .standard(proto: "initial_accum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.momentum)
      case 2: try decoder.decodeSingularBoolField(value: &self.useNesterov)
      case 3: try decoder.decodeSingularFloatField(value: &self.initialAccum)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.momentum != 0 {
      try visitor.visitSingularFloatField(value: self.momentum, fieldNumber: 1)
    }
    if self.useNesterov != false {
      try visitor.visitSingularBoolField(value: self.useNesterov, fieldNumber: 2)
    }
    if self.initialAccum != 0 {
      try visitor.visitSingularFloatField(value: self.initialAccum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_MomentumParameters, rhs: Tensorflow_Tpu_MomentumParameters) -> Bool {
    if lhs.momentum != rhs.momentum {return false}
    if lhs.useNesterov != rhs.useNesterov {return false}
    if lhs.initialAccum != rhs.initialAccum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_RmsPropParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RmsPropParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rho"),
    2: .same(proto: "momentum"),
    3: .same(proto: "epsilon"),
    4: .standard(proto: "initial_ms"),
    5: .standard(proto: "initial_mom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.rho)
      case 2: try decoder.decodeSingularFloatField(value: &self.momentum)
      case 3: try decoder.decodeSingularFloatField(value: &self.epsilon)
      case 4: try decoder.decodeSingularFloatField(value: &self.initialMs)
      case 5: try decoder.decodeSingularFloatField(value: &self.initialMom)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rho != 0 {
      try visitor.visitSingularFloatField(value: self.rho, fieldNumber: 1)
    }
    if self.momentum != 0 {
      try visitor.visitSingularFloatField(value: self.momentum, fieldNumber: 2)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 3)
    }
    if self.initialMs != 0 {
      try visitor.visitSingularFloatField(value: self.initialMs, fieldNumber: 4)
    }
    if self.initialMom != 0 {
      try visitor.visitSingularFloatField(value: self.initialMom, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_RmsPropParameters, rhs: Tensorflow_Tpu_RmsPropParameters) -> Bool {
    if lhs.rho != rhs.rho {return false}
    if lhs.momentum != rhs.momentum {return false}
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.initialMs != rhs.initialMs {return false}
    if lhs.initialMom != rhs.initialMom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_CenteredRmsPropParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CenteredRmsPropParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rho"),
    2: .same(proto: "momentum"),
    3: .same(proto: "epsilon"),
    4: .standard(proto: "initial_ms"),
    5: .standard(proto: "initial_mom"),
    6: .standard(proto: "initial_mg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.rho)
      case 2: try decoder.decodeSingularFloatField(value: &self.momentum)
      case 3: try decoder.decodeSingularFloatField(value: &self.epsilon)
      case 4: try decoder.decodeSingularFloatField(value: &self.initialMs)
      case 5: try decoder.decodeSingularFloatField(value: &self.initialMom)
      case 6: try decoder.decodeSingularFloatField(value: &self.initialMg)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rho != 0 {
      try visitor.visitSingularFloatField(value: self.rho, fieldNumber: 1)
    }
    if self.momentum != 0 {
      try visitor.visitSingularFloatField(value: self.momentum, fieldNumber: 2)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 3)
    }
    if self.initialMs != 0 {
      try visitor.visitSingularFloatField(value: self.initialMs, fieldNumber: 4)
    }
    if self.initialMom != 0 {
      try visitor.visitSingularFloatField(value: self.initialMom, fieldNumber: 5)
    }
    if self.initialMg != 0 {
      try visitor.visitSingularFloatField(value: self.initialMg, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_CenteredRmsPropParameters, rhs: Tensorflow_Tpu_CenteredRmsPropParameters) -> Bool {
    if lhs.rho != rhs.rho {return false}
    if lhs.momentum != rhs.momentum {return false}
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.initialMs != rhs.initialMs {return false}
    if lhs.initialMom != rhs.initialMom {return false}
    if lhs.initialMg != rhs.initialMg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_MdlAdagradLightParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MdlAdagradLightParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "l2"),
    2: .standard(proto: "lr_power"),
    3: .standard(proto: "min_servable_mdl_benefit"),
    4: .standard(proto: "mdl_mix_in_margin"),
    5: .standard(proto: "mdl_benefit_rampup_coeff"),
    6: .standard(proto: "mdl_min_weight"),
    7: .standard(proto: "benefit_revisit_scale"),
    8: .standard(proto: "max_event_benefit"),
    9: .standard(proto: "max_total_benefit"),
    10: .standard(proto: "mdl_hard_limit"),
    11: .standard(proto: "hard_limit_min_benefit"),
    12: .standard(proto: "mdl_regularize"),
    13: .standard(proto: "initial_accumulator"),
    14: .standard(proto: "initial_weight"),
    15: .standard(proto: "initial_benefit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.l2)
      case 2: try decoder.decodeSingularFloatField(value: &self.lrPower)
      case 3: try decoder.decodeSingularFloatField(value: &self.minServableMdlBenefit)
      case 4: try decoder.decodeSingularFloatField(value: &self.mdlMixInMargin)
      case 5: try decoder.decodeSingularFloatField(value: &self.mdlBenefitRampupCoeff)
      case 6: try decoder.decodeSingularFloatField(value: &self.mdlMinWeight)
      case 7: try decoder.decodeSingularFloatField(value: &self.benefitRevisitScale)
      case 8: try decoder.decodeSingularFloatField(value: &self.maxEventBenefit)
      case 9: try decoder.decodeSingularFloatField(value: &self.maxTotalBenefit)
      case 10: try decoder.decodeSingularFloatField(value: &self.mdlHardLimit)
      case 11: try decoder.decodeSingularBoolField(value: &self.hardLimitMinBenefit)
      case 12: try decoder.decodeSingularBoolField(value: &self.mdlRegularize)
      case 13: try decoder.decodeSingularFloatField(value: &self.initialAccumulator)
      case 14: try decoder.decodeSingularFloatField(value: &self.initialWeight)
      case 15: try decoder.decodeSingularFloatField(value: &self.initialBenefit)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.l2 != 0 {
      try visitor.visitSingularFloatField(value: self.l2, fieldNumber: 1)
    }
    if self.lrPower != 0 {
      try visitor.visitSingularFloatField(value: self.lrPower, fieldNumber: 2)
    }
    if self.minServableMdlBenefit != 0 {
      try visitor.visitSingularFloatField(value: self.minServableMdlBenefit, fieldNumber: 3)
    }
    if self.mdlMixInMargin != 0 {
      try visitor.visitSingularFloatField(value: self.mdlMixInMargin, fieldNumber: 4)
    }
    if self.mdlBenefitRampupCoeff != 0 {
      try visitor.visitSingularFloatField(value: self.mdlBenefitRampupCoeff, fieldNumber: 5)
    }
    if self.mdlMinWeight != 0 {
      try visitor.visitSingularFloatField(value: self.mdlMinWeight, fieldNumber: 6)
    }
    if self.benefitRevisitScale != 0 {
      try visitor.visitSingularFloatField(value: self.benefitRevisitScale, fieldNumber: 7)
    }
    if self.maxEventBenefit != 0 {
      try visitor.visitSingularFloatField(value: self.maxEventBenefit, fieldNumber: 8)
    }
    if self.maxTotalBenefit != 0 {
      try visitor.visitSingularFloatField(value: self.maxTotalBenefit, fieldNumber: 9)
    }
    if self.mdlHardLimit != 0 {
      try visitor.visitSingularFloatField(value: self.mdlHardLimit, fieldNumber: 10)
    }
    if self.hardLimitMinBenefit != false {
      try visitor.visitSingularBoolField(value: self.hardLimitMinBenefit, fieldNumber: 11)
    }
    if self.mdlRegularize != false {
      try visitor.visitSingularBoolField(value: self.mdlRegularize, fieldNumber: 12)
    }
    if self.initialAccumulator != 0 {
      try visitor.visitSingularFloatField(value: self.initialAccumulator, fieldNumber: 13)
    }
    if self.initialWeight != 0 {
      try visitor.visitSingularFloatField(value: self.initialWeight, fieldNumber: 14)
    }
    if self.initialBenefit != 0 {
      try visitor.visitSingularFloatField(value: self.initialBenefit, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_MdlAdagradLightParameters, rhs: Tensorflow_Tpu_MdlAdagradLightParameters) -> Bool {
    if lhs.l2 != rhs.l2 {return false}
    if lhs.lrPower != rhs.lrPower {return false}
    if lhs.minServableMdlBenefit != rhs.minServableMdlBenefit {return false}
    if lhs.mdlMixInMargin != rhs.mdlMixInMargin {return false}
    if lhs.mdlBenefitRampupCoeff != rhs.mdlBenefitRampupCoeff {return false}
    if lhs.mdlMinWeight != rhs.mdlMinWeight {return false}
    if lhs.benefitRevisitScale != rhs.benefitRevisitScale {return false}
    if lhs.maxEventBenefit != rhs.maxEventBenefit {return false}
    if lhs.maxTotalBenefit != rhs.maxTotalBenefit {return false}
    if lhs.mdlHardLimit != rhs.mdlHardLimit {return false}
    if lhs.hardLimitMinBenefit != rhs.hardLimitMinBenefit {return false}
    if lhs.mdlRegularize != rhs.mdlRegularize {return false}
    if lhs.initialAccumulator != rhs.initialAccumulator {return false}
    if lhs.initialWeight != rhs.initialWeight {return false}
    if lhs.initialBenefit != rhs.initialBenefit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_AdadeltaParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdadeltaParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rho"),
    2: .same(proto: "epsilon"),
    3: .standard(proto: "initial_accumulator"),
    4: .standard(proto: "initial_update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.rho)
      case 2: try decoder.decodeSingularFloatField(value: &self.epsilon)
      case 3: try decoder.decodeSingularFloatField(value: &self.initialAccumulator)
      case 4: try decoder.decodeSingularFloatField(value: &self.initialUpdate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rho != 0 {
      try visitor.visitSingularFloatField(value: self.rho, fieldNumber: 1)
    }
    if self.epsilon != 0 {
      try visitor.visitSingularFloatField(value: self.epsilon, fieldNumber: 2)
    }
    if self.initialAccumulator != 0 {
      try visitor.visitSingularFloatField(value: self.initialAccumulator, fieldNumber: 3)
    }
    if self.initialUpdate != 0 {
      try visitor.visitSingularFloatField(value: self.initialUpdate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_AdadeltaParameters, rhs: Tensorflow_Tpu_AdadeltaParameters) -> Bool {
    if lhs.rho != rhs.rho {return false}
    if lhs.epsilon != rhs.epsilon {return false}
    if lhs.initialAccumulator != rhs.initialAccumulator {return false}
    if lhs.initialUpdate != rhs.initialUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_ProximalAdagradParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProximalAdagradParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "l1"),
    2: .same(proto: "l2"),
    3: .standard(proto: "initial_accumulator"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.l1)
      case 2: try decoder.decodeSingularFloatField(value: &self.l2)
      case 3: try decoder.decodeSingularFloatField(value: &self.initialAccumulator)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.l1 != 0 {
      try visitor.visitSingularFloatField(value: self.l1, fieldNumber: 1)
    }
    if self.l2 != 0 {
      try visitor.visitSingularFloatField(value: self.l2, fieldNumber: 2)
    }
    if self.initialAccumulator != 0 {
      try visitor.visitSingularFloatField(value: self.initialAccumulator, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_ProximalAdagradParameters, rhs: Tensorflow_Tpu_ProximalAdagradParameters) -> Bool {
    if lhs.l1 != rhs.l1 {return false}
    if lhs.l2 != rhs.l2 {return false}
    if lhs.initialAccumulator != rhs.initialAccumulator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_OptimizationParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptimizationParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    13: .standard(proto: "learning_rate"),
    2: .standard(proto: "clipping_limits"),
    7: .standard(proto: "gradient_clipping_limits"),
    16: .standard(proto: "weight_decay_factor"),
    15: .standard(proto: "use_gradient_accumulation"),
    3: .same(proto: "adagrad"),
    4: .standard(proto: "stochastic_gradient_descent"),
    5: .same(proto: "ftrl"),
    6: .same(proto: "adam"),
    8: .same(proto: "momentum"),
    9: .standard(proto: "rms_prop"),
    10: .standard(proto: "centered_rms_prop"),
    11: .standard(proto: "mdl_adagrad_light"),
    12: .same(proto: "adadelta"),
    14: .standard(proto: "proximal_adagrad"),
  ]

  fileprivate class _StorageClass {
    var _learningRate: Tensorflow_Tpu_LearningRate? = nil
    var _clippingLimits: Tensorflow_Tpu_ClippingLimits? = nil
    var _gradientClippingLimits: Tensorflow_Tpu_ClippingLimits? = nil
    var _weightDecayFactor: Float = 0
    var _useGradientAccumulation: Bool = false
    var _parameters: Tensorflow_Tpu_OptimizationParameters.OneOf_Parameters?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _learningRate = source._learningRate
      _clippingLimits = source._clippingLimits
      _gradientClippingLimits = source._gradientClippingLimits
      _weightDecayFactor = source._weightDecayFactor
      _useGradientAccumulation = source._useGradientAccumulation
      _parameters = source._parameters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularMessageField(value: &_storage._clippingLimits)
        case 3:
          var v: Tensorflow_Tpu_AdagradParameters?
          if let current = _storage._parameters {
            try decoder.handleConflictingOneOf()
            if case .adagrad(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parameters = .adagrad(v)}
        case 4:
          var v: Tensorflow_Tpu_StochasticGradientDescentParameters?
          if let current = _storage._parameters {
            try decoder.handleConflictingOneOf()
            if case .stochasticGradientDescent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parameters = .stochasticGradientDescent(v)}
        case 5:
          var v: Tensorflow_Tpu_FtrlParameters?
          if let current = _storage._parameters {
            try decoder.handleConflictingOneOf()
            if case .ftrl(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parameters = .ftrl(v)}
        case 6:
          var v: Tensorflow_Tpu_AdamParameters?
          if let current = _storage._parameters {
            try decoder.handleConflictingOneOf()
            if case .adam(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parameters = .adam(v)}
        case 7: try decoder.decodeSingularMessageField(value: &_storage._gradientClippingLimits)
        case 8:
          var v: Tensorflow_Tpu_MomentumParameters?
          if let current = _storage._parameters {
            try decoder.handleConflictingOneOf()
            if case .momentum(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parameters = .momentum(v)}
        case 9:
          var v: Tensorflow_Tpu_RmsPropParameters?
          if let current = _storage._parameters {
            try decoder.handleConflictingOneOf()
            if case .rmsProp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parameters = .rmsProp(v)}
        case 10:
          var v: Tensorflow_Tpu_CenteredRmsPropParameters?
          if let current = _storage._parameters {
            try decoder.handleConflictingOneOf()
            if case .centeredRmsProp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parameters = .centeredRmsProp(v)}
        case 11:
          var v: Tensorflow_Tpu_MdlAdagradLightParameters?
          if let current = _storage._parameters {
            try decoder.handleConflictingOneOf()
            if case .mdlAdagradLight(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parameters = .mdlAdagradLight(v)}
        case 12:
          var v: Tensorflow_Tpu_AdadeltaParameters?
          if let current = _storage._parameters {
            try decoder.handleConflictingOneOf()
            if case .adadelta(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parameters = .adadelta(v)}
        case 13: try decoder.decodeSingularMessageField(value: &_storage._learningRate)
        case 14:
          var v: Tensorflow_Tpu_ProximalAdagradParameters?
          if let current = _storage._parameters {
            try decoder.handleConflictingOneOf()
            if case .proximalAdagrad(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._parameters = .proximalAdagrad(v)}
        case 15: try decoder.decodeSingularBoolField(value: &_storage._useGradientAccumulation)
        case 16: try decoder.decodeSingularFloatField(value: &_storage._weightDecayFactor)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._clippingLimits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      switch _storage._parameters {
      case .adagrad(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .stochasticGradientDescent(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .ftrl(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .adam(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      default: break
      }
      if let v = _storage._gradientClippingLimits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      switch _storage._parameters {
      case .momentum(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .rmsProp(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .centeredRmsProp(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .mdlAdagradLight(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .adadelta(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case nil: break
      default: break
      }
      if let v = _storage._learningRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if case .proximalAdagrad(let v)? = _storage._parameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if _storage._useGradientAccumulation != false {
        try visitor.visitSingularBoolField(value: _storage._useGradientAccumulation, fieldNumber: 15)
      }
      if _storage._weightDecayFactor != 0 {
        try visitor.visitSingularFloatField(value: _storage._weightDecayFactor, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_OptimizationParameters, rhs: Tensorflow_Tpu_OptimizationParameters) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._learningRate != rhs_storage._learningRate {return false}
        if _storage._clippingLimits != rhs_storage._clippingLimits {return false}
        if _storage._gradientClippingLimits != rhs_storage._gradientClippingLimits {return false}
        if _storage._weightDecayFactor != rhs_storage._weightDecayFactor {return false}
        if _storage._useGradientAccumulation != rhs_storage._useGradientAccumulation {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_StateVariableSpecification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateVariableSpecification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "user_defined"),
    3: .standard(proto: "fill_with_constant"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _usage: Tensorflow_Tpu_StateVariableSpecification.OneOf_Usage?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _usage = source._usage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2:
          var v: Tensorflow_Tpu_StateVariableSpecification.UserDefined?
          if let current = _storage._usage {
            try decoder.handleConflictingOneOf()
            if case .userDefined(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._usage = .userDefined(v)}
        case 3:
          var v: Tensorflow_Tpu_StateVariableSpecification.FillWithConstant?
          if let current = _storage._usage {
            try decoder.handleConflictingOneOf()
            if case .fillWithConstant(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._usage = .fillWithConstant(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      switch _storage._usage {
      case .userDefined(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .fillWithConstant(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_StateVariableSpecification, rhs: Tensorflow_Tpu_StateVariableSpecification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._usage != rhs_storage._usage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_StateVariableSpecification.UserDefined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tensorflow_Tpu_StateVariableSpecification.protoMessageName + ".UserDefined"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_StateVariableSpecification.UserDefined, rhs: Tensorflow_Tpu_StateVariableSpecification.UserDefined) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tpu_StateVariableSpecification.FillWithConstant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tensorflow_Tpu_StateVariableSpecification.protoMessageName + ".FillWithConstant"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initial_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.initialValue)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.initialValue != 0 {
      try visitor.visitSingularDoubleField(value: self.initialValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_Tpu_StateVariableSpecification.FillWithConstant, rhs: Tensorflow_Tpu_StateVariableSpecification.FillWithConstant) -> Bool {
    if lhs.initialValue != rhs.initialValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
