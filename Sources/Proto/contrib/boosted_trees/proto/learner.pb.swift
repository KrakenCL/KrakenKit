// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/contrib/boosted_trees/proto/learner.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Tree regularization config.
public struct Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Classic L1/L2.
  public var l1: Float = 0

  public var l2: Float = 0

  /// Tree complexity penalizes overall model complexity effectively
  /// limiting how deep the tree can grow in regions with small gain.
  public var treeComplexity: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Tree constraints config.
public struct Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Maximum depth of the trees. The default value is 6 if not specified.
  public var maxTreeDepth: UInt32 = 0

  /// Min hessian weight per node.
  public var minNodeWeight: Float = 0

  /// Maximum number of unique features used in the tree. Zero means there is no
  /// limit.
  public var maxNumberOfUniqueFeatureColumns: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// LearningRateConfig describes all supported learning rate tuners.
public struct Tensorflow_BoostedTrees_Learner_LearningRateConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tuner: OneOf_Tuner? {
    get {return _storage._tuner}
    set {_uniqueStorage()._tuner = newValue}
  }

  public var fixed: Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig {
    get {
      if case .fixed(let v)? = _storage._tuner {return v}
      return Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig()
    }
    set {_uniqueStorage()._tuner = .fixed(newValue)}
  }

  public var dropout: Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig {
    get {
      if case .dropout(let v)? = _storage._tuner {return v}
      return Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig()
    }
    set {_uniqueStorage()._tuner = .dropout(newValue)}
  }

  public var lineSearch: Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig {
    get {
      if case .lineSearch(let v)? = _storage._tuner {return v}
      return Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig()
    }
    set {_uniqueStorage()._tuner = .lineSearch(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Tuner: Equatable {
    case fixed(Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig)
    case dropout(Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig)
    case lineSearch(Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Tensorflow_BoostedTrees_Learner_LearningRateConfig.OneOf_Tuner, rhs: Tensorflow_BoostedTrees_Learner_LearningRateConfig.OneOf_Tuner) -> Bool {
      switch (lhs, rhs) {
      case (.fixed(let l), .fixed(let r)): return l == r
      case (.dropout(let l), .dropout(let r)): return l == r
      case (.lineSearch(let l), .lineSearch(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Config for a fixed learning rate.
public struct Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var learningRate: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Config for a tuned learning rate.
public struct Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Max learning rate. Must be strictly positive.
  public var maxLearningRate: Float = 0

  /// Number of learning rate values to consider between [0, max_learning_rate).
  public var numSteps: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// When we have a sequence of trees 1, 2, 3 ... n, these essentially represent
/// weights updates in functional space, and thus we can use averaging of weight
/// updates to achieve better performance. For example, we can say that our final
/// ensemble will be an average of ensembles of tree 1, and ensemble of tree 1
/// and tree 2 etc .. ensemble of all trees.
/// Note that this averaging will apply ONLY DURING PREDICTION. The training
/// stays the same.
public struct Tensorflow_BoostedTrees_Learner_AveragingConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var config: Tensorflow_BoostedTrees_Learner_AveragingConfig.OneOf_Config? = nil

  public var averageLastNTrees: Float {
    get {
      if case .averageLastNTrees(let v)? = config {return v}
      return 0
    }
    set {config = .averageLastNTrees(newValue)}
  }

  /// Between 0 and 1. If set to 1.0, we are averaging ensembles of tree 1,
  /// ensemble of tree 1 and tree 2, etc ensemble of all trees. If set to 0.5,
  /// last half of the trees are averaged etc.
  public var averageLastPercentTrees: Float {
    get {
      if case .averageLastPercentTrees(let v)? = config {return v}
      return 0
    }
    set {config = .averageLastPercentTrees(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Config: Equatable {
    case averageLastNTrees(Float)
    /// Between 0 and 1. If set to 1.0, we are averaging ensembles of tree 1,
    /// ensemble of tree 1 and tree 2, etc ensemble of all trees. If set to 0.5,
    /// last half of the trees are averaged etc.
    case averageLastPercentTrees(Float)

  #if !swift(>=4.1)
    public static func ==(lhs: Tensorflow_BoostedTrees_Learner_AveragingConfig.OneOf_Config, rhs: Tensorflow_BoostedTrees_Learner_AveragingConfig.OneOf_Config) -> Bool {
      switch (lhs, rhs) {
      case (.averageLastNTrees(let l), .averageLastNTrees(let r)): return l == r
      case (.averageLastPercentTrees(let l), .averageLastPercentTrees(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Probability of dropping each tree in an existing so far ensemble.
  public var dropoutProbability: Float = 0

  /// When trees are built after dropout happen, they don't "advance" to the
  /// optimal solution, they just rearrange the path. However you can still
  /// choose to skip dropout periodically, to allow a new tree that "advances"
  /// to be added.
  /// For example, if running for 200 steps with probability of dropout 1/100,
  /// you would expect the dropout to start happening for sure for all iterations
  /// after 100. However you can add probability_of_skipping_dropout of 0.1, this
  /// way iterations 100-200 will include approx 90 iterations of dropout and 10
  /// iterations of normal steps.Set it to 0 if you want just keep building
  /// the refinement trees after dropout kicks in.
  public var probabilityOfSkippingDropout: Float = 0

  /// Between 0 and 1.
  public var learningRate: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tensorflow_BoostedTrees_Learner_LearnerConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of classes.
  public var numClasses: UInt32 {
    get {return _storage._numClasses}
    set {_uniqueStorage()._numClasses = newValue}
  }

  /// Fraction of features to consider in each tree sampled randomly
  /// from all available features.
  public var featureFraction: OneOf_FeatureFraction? {
    get {return _storage._featureFraction}
    set {_uniqueStorage()._featureFraction = newValue}
  }

  public var featureFractionPerTree: Float {
    get {
      if case .featureFractionPerTree(let v)? = _storage._featureFraction {return v}
      return 0
    }
    set {_uniqueStorage()._featureFraction = .featureFractionPerTree(newValue)}
  }

  public var featureFractionPerLevel: Float {
    get {
      if case .featureFractionPerLevel(let v)? = _storage._featureFraction {return v}
      return 0
    }
    set {_uniqueStorage()._featureFraction = .featureFractionPerLevel(newValue)}
  }

  /// Regularization.
  public var regularization: Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig {
    get {return _storage._regularization ?? Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig()}
    set {_uniqueStorage()._regularization = newValue}
  }
  /// Returns true if `regularization` has been explicitly set.
  public var hasRegularization: Bool {return _storage._regularization != nil}
  /// Clears the value of `regularization`. Subsequent reads from it will return its default value.
  public mutating func clearRegularization() {_uniqueStorage()._regularization = nil}

  /// Constraints.
  public var constraints: Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig {
    get {return _storage._constraints ?? Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig()}
    set {_uniqueStorage()._constraints = newValue}
  }
  /// Returns true if `constraints` has been explicitly set.
  public var hasConstraints: Bool {return _storage._constraints != nil}
  /// Clears the value of `constraints`. Subsequent reads from it will return its default value.
  public mutating func clearConstraints() {_uniqueStorage()._constraints = nil}

  /// Pruning. POST_PRUNE is the default pruning mode.
  public var pruningMode: Tensorflow_BoostedTrees_Learner_LearnerConfig.PruningMode {
    get {return _storage._pruningMode}
    set {_uniqueStorage()._pruningMode = newValue}
  }

  /// Growing Mode. LAYER_BY_LAYER is the default growing mode.
  public var growingMode: Tensorflow_BoostedTrees_Learner_LearnerConfig.GrowingMode {
    get {return _storage._growingMode}
    set {_uniqueStorage()._growingMode = newValue}
  }

  /// Learning rate. By default we use fixed learning rate of 0.1.
  public var learningRateTuner: Tensorflow_BoostedTrees_Learner_LearningRateConfig {
    get {return _storage._learningRateTuner ?? Tensorflow_BoostedTrees_Learner_LearningRateConfig()}
    set {_uniqueStorage()._learningRateTuner = newValue}
  }
  /// Returns true if `learningRateTuner` has been explicitly set.
  public var hasLearningRateTuner: Bool {return _storage._learningRateTuner != nil}
  /// Clears the value of `learningRateTuner`. Subsequent reads from it will return its default value.
  public mutating func clearLearningRateTuner() {_uniqueStorage()._learningRateTuner = nil}

  /// Multi-class strategy. By default we use TREE_PER_CLASS for binary
  /// classification and linear regression. For other cases, we use
  /// DIAGONAL_HESSIAN as the default.
  public var multiClassStrategy: Tensorflow_BoostedTrees_Learner_LearnerConfig.MultiClassStrategy {
    get {return _storage._multiClassStrategy}
    set {_uniqueStorage()._multiClassStrategy = newValue}
  }

  /// If you want to average the ensembles (for regularization), provide the
  /// config below.
  public var averagingConfig: Tensorflow_BoostedTrees_Learner_AveragingConfig {
    get {return _storage._averagingConfig ?? Tensorflow_BoostedTrees_Learner_AveragingConfig()}
    set {_uniqueStorage()._averagingConfig = newValue}
  }
  /// Returns true if `averagingConfig` has been explicitly set.
  public var hasAveragingConfig: Bool {return _storage._averagingConfig != nil}
  /// Clears the value of `averagingConfig`. Subsequent reads from it will return its default value.
  public mutating func clearAveragingConfig() {_uniqueStorage()._averagingConfig = nil}

  /// By default we use NORMAL_DECISION_TREE as weak learner.
  public var weakLearnerType: Tensorflow_BoostedTrees_Learner_LearnerConfig.WeakLearnerType {
    get {return _storage._weakLearnerType}
    set {_uniqueStorage()._weakLearnerType = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Fraction of features to consider in each tree sampled randomly
  /// from all available features.
  public enum OneOf_FeatureFraction: Equatable {
    case featureFractionPerTree(Float)
    case featureFractionPerLevel(Float)

  #if !swift(>=4.1)
    public static func ==(lhs: Tensorflow_BoostedTrees_Learner_LearnerConfig.OneOf_FeatureFraction, rhs: Tensorflow_BoostedTrees_Learner_LearnerConfig.OneOf_FeatureFraction) -> Bool {
      switch (lhs, rhs) {
      case (.featureFractionPerTree(let l), .featureFractionPerTree(let r)): return l == r
      case (.featureFractionPerLevel(let l), .featureFractionPerLevel(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum PruningMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case prePrune // = 1
    case postPrune // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .prePrune
      case 2: self = .postPrune
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .prePrune: return 1
      case .postPrune: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum GrowingMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case wholeTree // = 1
    case layerByLayer // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .wholeTree
      case 2: self = .layerByLayer
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .wholeTree: return 1
      case .layerByLayer: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum MultiClassStrategy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case treePerClass // = 1
    case fullHessian // = 2
    case diagonalHessian // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .treePerClass
      case 2: self = .fullHessian
      case 3: self = .diagonalHessian
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .treePerClass: return 1
      case .fullHessian: return 2
      case .diagonalHessian: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum WeakLearnerType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case normalDecisionTree // = 0
    case obliviousDecisionTree // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .normalDecisionTree
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normalDecisionTree
      case 1: self = .obliviousDecisionTree
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normalDecisionTree: return 0
      case .obliviousDecisionTree: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.PruningMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tensorflow_BoostedTrees_Learner_LearnerConfig.PruningMode] = [
    .unspecified,
    .prePrune,
    .postPrune,
  ]
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.GrowingMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tensorflow_BoostedTrees_Learner_LearnerConfig.GrowingMode] = [
    .unspecified,
    .wholeTree,
    .layerByLayer,
  ]
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.MultiClassStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tensorflow_BoostedTrees_Learner_LearnerConfig.MultiClassStrategy] = [
    .unspecified,
    .treePerClass,
    .fullHessian,
    .diagonalHessian,
  ]
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.WeakLearnerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Tensorflow_BoostedTrees_Learner_LearnerConfig.WeakLearnerType] = [
    .normalDecisionTree,
    .obliviousDecisionTree,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorflow.boosted_trees.learner"

extension Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TreeRegularizationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "l1"),
    2: .same(proto: "l2"),
    3: .standard(proto: "tree_complexity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.l1)
      case 2: try decoder.decodeSingularFloatField(value: &self.l2)
      case 3: try decoder.decodeSingularFloatField(value: &self.treeComplexity)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.l1 != 0 {
      try visitor.visitSingularFloatField(value: self.l1, fieldNumber: 1)
    }
    if self.l2 != 0 {
      try visitor.visitSingularFloatField(value: self.l2, fieldNumber: 2)
    }
    if self.treeComplexity != 0 {
      try visitor.visitSingularFloatField(value: self.treeComplexity, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig, rhs: Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig) -> Bool {
    if lhs.l1 != rhs.l1 {return false}
    if lhs.l2 != rhs.l2 {return false}
    if lhs.treeComplexity != rhs.treeComplexity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TreeConstraintsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_tree_depth"),
    2: .standard(proto: "min_node_weight"),
    3: .standard(proto: "max_number_of_unique_feature_columns"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.maxTreeDepth)
      case 2: try decoder.decodeSingularFloatField(value: &self.minNodeWeight)
      case 3: try decoder.decodeSingularInt64Field(value: &self.maxNumberOfUniqueFeatureColumns)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxTreeDepth != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxTreeDepth, fieldNumber: 1)
    }
    if self.minNodeWeight != 0 {
      try visitor.visitSingularFloatField(value: self.minNodeWeight, fieldNumber: 2)
    }
    if self.maxNumberOfUniqueFeatureColumns != 0 {
      try visitor.visitSingularInt64Field(value: self.maxNumberOfUniqueFeatureColumns, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig, rhs: Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig) -> Bool {
    if lhs.maxTreeDepth != rhs.maxTreeDepth {return false}
    if lhs.minNodeWeight != rhs.minNodeWeight {return false}
    if lhs.maxNumberOfUniqueFeatureColumns != rhs.maxNumberOfUniqueFeatureColumns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_LearningRateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LearningRateConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fixed"),
    2: .same(proto: "dropout"),
    3: .standard(proto: "line_search"),
  ]

  fileprivate class _StorageClass {
    var _tuner: Tensorflow_BoostedTrees_Learner_LearningRateConfig.OneOf_Tuner?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tuner = source._tuner
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig?
          if let current = _storage._tuner {
            try decoder.handleConflictingOneOf()
            if case .fixed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._tuner = .fixed(v)}
        case 2:
          var v: Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig?
          if let current = _storage._tuner {
            try decoder.handleConflictingOneOf()
            if case .dropout(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._tuner = .dropout(v)}
        case 3:
          var v: Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig?
          if let current = _storage._tuner {
            try decoder.handleConflictingOneOf()
            if case .lineSearch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._tuner = .lineSearch(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._tuner {
      case .fixed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .dropout(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .lineSearch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_BoostedTrees_Learner_LearningRateConfig, rhs: Tensorflow_BoostedTrees_Learner_LearningRateConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tuner != rhs_storage._tuner {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LearningRateFixedConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "learning_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.learningRate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.learningRate != 0 {
      try visitor.visitSingularFloatField(value: self.learningRate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig, rhs: Tensorflow_BoostedTrees_Learner_LearningRateFixedConfig) -> Bool {
    if lhs.learningRate != rhs.learningRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LearningRateLineSearchConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_learning_rate"),
    2: .standard(proto: "num_steps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.maxLearningRate)
      case 2: try decoder.decodeSingularInt32Field(value: &self.numSteps)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxLearningRate != 0 {
      try visitor.visitSingularFloatField(value: self.maxLearningRate, fieldNumber: 1)
    }
    if self.numSteps != 0 {
      try visitor.visitSingularInt32Field(value: self.numSteps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig, rhs: Tensorflow_BoostedTrees_Learner_LearningRateLineSearchConfig) -> Bool {
    if lhs.maxLearningRate != rhs.maxLearningRate {return false}
    if lhs.numSteps != rhs.numSteps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_AveragingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AveragingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "average_last_n_trees"),
    2: .standard(proto: "average_last_percent_trees"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.config != nil {try decoder.handleConflictingOneOf()}
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {self.config = .averageLastNTrees(v)}
      case 2:
        if self.config != nil {try decoder.handleConflictingOneOf()}
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {self.config = .averageLastPercentTrees(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.config {
    case .averageLastNTrees(let v)?:
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    case .averageLastPercentTrees(let v)?:
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_BoostedTrees_Learner_AveragingConfig, rhs: Tensorflow_BoostedTrees_Learner_AveragingConfig) -> Bool {
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LearningRateDropoutDrivenConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dropout_probability"),
    2: .standard(proto: "probability_of_skipping_dropout"),
    3: .standard(proto: "learning_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.dropoutProbability)
      case 2: try decoder.decodeSingularFloatField(value: &self.probabilityOfSkippingDropout)
      case 3: try decoder.decodeSingularFloatField(value: &self.learningRate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dropoutProbability != 0 {
      try visitor.visitSingularFloatField(value: self.dropoutProbability, fieldNumber: 1)
    }
    if self.probabilityOfSkippingDropout != 0 {
      try visitor.visitSingularFloatField(value: self.probabilityOfSkippingDropout, fieldNumber: 2)
    }
    if self.learningRate != 0 {
      try visitor.visitSingularFloatField(value: self.learningRate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig, rhs: Tensorflow_BoostedTrees_Learner_LearningRateDropoutDrivenConfig) -> Bool {
    if lhs.dropoutProbability != rhs.dropoutProbability {return false}
    if lhs.probabilityOfSkippingDropout != rhs.probabilityOfSkippingDropout {return false}
    if lhs.learningRate != rhs.learningRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LearnerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_classes"),
    2: .standard(proto: "feature_fraction_per_tree"),
    3: .standard(proto: "feature_fraction_per_level"),
    4: .same(proto: "regularization"),
    5: .same(proto: "constraints"),
    8: .standard(proto: "pruning_mode"),
    9: .standard(proto: "growing_mode"),
    6: .standard(proto: "learning_rate_tuner"),
    10: .standard(proto: "multi_class_strategy"),
    11: .standard(proto: "averaging_config"),
    12: .standard(proto: "weak_learner_type"),
  ]

  fileprivate class _StorageClass {
    var _numClasses: UInt32 = 0
    var _featureFraction: Tensorflow_BoostedTrees_Learner_LearnerConfig.OneOf_FeatureFraction?
    var _regularization: Tensorflow_BoostedTrees_Learner_TreeRegularizationConfig? = nil
    var _constraints: Tensorflow_BoostedTrees_Learner_TreeConstraintsConfig? = nil
    var _pruningMode: Tensorflow_BoostedTrees_Learner_LearnerConfig.PruningMode = .unspecified
    var _growingMode: Tensorflow_BoostedTrees_Learner_LearnerConfig.GrowingMode = .unspecified
    var _learningRateTuner: Tensorflow_BoostedTrees_Learner_LearningRateConfig? = nil
    var _multiClassStrategy: Tensorflow_BoostedTrees_Learner_LearnerConfig.MultiClassStrategy = .unspecified
    var _averagingConfig: Tensorflow_BoostedTrees_Learner_AveragingConfig? = nil
    var _weakLearnerType: Tensorflow_BoostedTrees_Learner_LearnerConfig.WeakLearnerType = .normalDecisionTree

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _numClasses = source._numClasses
      _featureFraction = source._featureFraction
      _regularization = source._regularization
      _constraints = source._constraints
      _pruningMode = source._pruningMode
      _growingMode = source._growingMode
      _learningRateTuner = source._learningRateTuner
      _multiClassStrategy = source._multiClassStrategy
      _averagingConfig = source._averagingConfig
      _weakLearnerType = source._weakLearnerType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._numClasses)
        case 2:
          if _storage._featureFraction != nil {try decoder.handleConflictingOneOf()}
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {_storage._featureFraction = .featureFractionPerTree(v)}
        case 3:
          if _storage._featureFraction != nil {try decoder.handleConflictingOneOf()}
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {_storage._featureFraction = .featureFractionPerLevel(v)}
        case 4: try decoder.decodeSingularMessageField(value: &_storage._regularization)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._constraints)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._learningRateTuner)
        case 8: try decoder.decodeSingularEnumField(value: &_storage._pruningMode)
        case 9: try decoder.decodeSingularEnumField(value: &_storage._growingMode)
        case 10: try decoder.decodeSingularEnumField(value: &_storage._multiClassStrategy)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._averagingConfig)
        case 12: try decoder.decodeSingularEnumField(value: &_storage._weakLearnerType)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._numClasses != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._numClasses, fieldNumber: 1)
      }
      switch _storage._featureFraction {
      case .featureFractionPerTree(let v)?:
        try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
      case .featureFractionPerLevel(let v)?:
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      case nil: break
      }
      if let v = _storage._regularization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._constraints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._learningRateTuner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._pruningMode != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._pruningMode, fieldNumber: 8)
      }
      if _storage._growingMode != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._growingMode, fieldNumber: 9)
      }
      if _storage._multiClassStrategy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._multiClassStrategy, fieldNumber: 10)
      }
      if let v = _storage._averagingConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if _storage._weakLearnerType != .normalDecisionTree {
        try visitor.visitSingularEnumField(value: _storage._weakLearnerType, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tensorflow_BoostedTrees_Learner_LearnerConfig, rhs: Tensorflow_BoostedTrees_Learner_LearnerConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._numClasses != rhs_storage._numClasses {return false}
        if _storage._featureFraction != rhs_storage._featureFraction {return false}
        if _storage._regularization != rhs_storage._regularization {return false}
        if _storage._constraints != rhs_storage._constraints {return false}
        if _storage._pruningMode != rhs_storage._pruningMode {return false}
        if _storage._growingMode != rhs_storage._growingMode {return false}
        if _storage._learningRateTuner != rhs_storage._learningRateTuner {return false}
        if _storage._multiClassStrategy != rhs_storage._multiClassStrategy {return false}
        if _storage._averagingConfig != rhs_storage._averagingConfig {return false}
        if _storage._weakLearnerType != rhs_storage._weakLearnerType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.PruningMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRUNING_MODE_UNSPECIFIED"),
    1: .same(proto: "PRE_PRUNE"),
    2: .same(proto: "POST_PRUNE"),
  ]
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.GrowingMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GROWING_MODE_UNSPECIFIED"),
    1: .same(proto: "WHOLE_TREE"),
    2: .same(proto: "LAYER_BY_LAYER"),
  ]
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.MultiClassStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MULTI_CLASS_STRATEGY_UNSPECIFIED"),
    1: .same(proto: "TREE_PER_CLASS"),
    2: .same(proto: "FULL_HESSIAN"),
    3: .same(proto: "DIAGONAL_HESSIAN"),
  ]
}

extension Tensorflow_BoostedTrees_Learner_LearnerConfig.WeakLearnerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL_DECISION_TREE"),
    1: .same(proto: "OBLIVIOUS_DECISION_TREE"),
  ]
}
