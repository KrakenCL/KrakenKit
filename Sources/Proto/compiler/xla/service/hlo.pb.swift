// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/compiler/xla/service/hlo.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 The TensorFlow Authors. All Rights Reserved.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//==============================================================================

// This proto file defines messages which represent the HLO module. This is a
// full fidelity serialization of the c++ HLO constructs.
//
// Many of the protos below are simple 1-to-1 serializations of the
// corresponding C++ classes, e.g., HloModule, HloComputation, and
// HloInstruction.
//
// FIELD NAMES ARE IMPORTANT
//
// Unlike most protos, you can't safely change the names of fields, even if you
// keep the numeric ids the same. This is because we sometimes serialize these
// protos as JSON, which includes the field names in the serialization.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Serialization of HloInstruction.
/// Next ID: 59
public struct Xla_HloInstructionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var opcode: String {
    get {return _storage._opcode}
    set {_uniqueStorage()._opcode = newValue}
  }

  public var shape: Xla_ShapeProto {
    get {return _storage._shape ?? Xla_ShapeProto()}
    set {_uniqueStorage()._shape = newValue}
  }
  /// Returns true if `shape` has been explicitly set.
  public var hasShape: Bool {return _storage._shape != nil}
  /// Clears the value of `shape`. Subsequent reads from it will return its default value.
  public mutating func clearShape() {_uniqueStorage()._shape = nil}

  public var metadata: Xla_OpMetadata {
    get {return _storage._metadata ?? Xla_OpMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Literal, only present for kConstant.
  public var literal: Xla_LiteralProto {
    get {return _storage._literal ?? Xla_LiteralProto()}
    set {_uniqueStorage()._literal = newValue}
  }
  /// Returns true if `literal` has been explicitly set.
  public var hasLiteral: Bool {return _storage._literal != nil}
  /// Clears the value of `literal`. Subsequent reads from it will return its default value.
  public mutating func clearLiteral() {_uniqueStorage()._literal = nil}

  /// Parameter number is only present for kParameter.
  public var parameterNumber: Int64 {
    get {return _storage._parameterNumber}
    set {_uniqueStorage()._parameterNumber = newValue}
  }

  /// Fusion state, only present for kFusion.
  public var fusionKind: String {
    get {return _storage._fusionKind}
    set {_uniqueStorage()._fusionKind = newValue}
  }

  /// Index for kGetTupleElement.
  public var tupleIndex: Int64 {
    get {return _storage._tupleIndex}
    set {_uniqueStorage()._tupleIndex = newValue}
  }

  /// Dimensions present for some operations that require reshaping or
  /// broadcasting, including Reshape, Reduce, ReduceWindow, and Reverse.
  public var dimensions: [Int64] {
    get {return _storage._dimensions}
    set {_uniqueStorage()._dimensions = newValue}
  }

  /// Describes the window in a windowed operation such as convolution.
  public var window: Xla_Window {
    get {return _storage._window ?? Xla_Window()}
    set {_uniqueStorage()._window = newValue}
  }
  /// Returns true if `window` has been explicitly set.
  public var hasWindow: Bool {return _storage._window != nil}
  /// Clears the value of `window`. Subsequent reads from it will return its default value.
  public mutating func clearWindow() {_uniqueStorage()._window = nil}

  /// Describes the dimension numbers used for a convolution.
  public var convolutionDimensionNumbers: Xla_ConvolutionDimensionNumbers {
    get {return _storage._convolutionDimensionNumbers ?? Xla_ConvolutionDimensionNumbers()}
    set {_uniqueStorage()._convolutionDimensionNumbers = newValue}
  }
  /// Returns true if `convolutionDimensionNumbers` has been explicitly set.
  public var hasConvolutionDimensionNumbers: Bool {return _storage._convolutionDimensionNumbers != nil}
  /// Clears the value of `convolutionDimensionNumbers`. Subsequent reads from it will return its default value.
  public mutating func clearConvolutionDimensionNumbers() {_uniqueStorage()._convolutionDimensionNumbers = nil}

  /// The number of feature groups. Used for a convolution. Must be a divisor of
  /// the input feature dimension and output feature dimension. If not specified,
  /// it will use a default value of 1.
  public var featureGroupCount: Int64 {
    get {return _storage._featureGroupCount}
    set {_uniqueStorage()._featureGroupCount = newValue}
  }

  public var batchGroupCount: Int64 {
    get {return _storage._batchGroupCount}
    set {_uniqueStorage()._batchGroupCount = newValue}
  }

  public var sliceDimensions: [Xla_HloInstructionProto.SliceDimensions] {
    get {return _storage._sliceDimensions}
    set {_uniqueStorage()._sliceDimensions = newValue}
  }

  /// The bit sizes for a reduce-precision operation.
  public var exponentBits: Int32 {
    get {return _storage._exponentBits}
    set {_uniqueStorage()._exponentBits = newValue}
  }

  public var mantissaBits: Int32 {
    get {return _storage._mantissaBits}
    set {_uniqueStorage()._mantissaBits = newValue}
  }

  /// Describes the [start, start + size) range size for a dynamic slice
  /// ('start' is specified dynamically in the second operand of the operation).
  public var dynamicSliceSizes: [Int64] {
    get {return _storage._dynamicSliceSizes}
    set {_uniqueStorage()._dynamicSliceSizes = newValue}
  }

  /// The padding configuration that describes the edge padding and interior
  /// padding of this pad instruction. Only set for pad instructions.
  public var paddingConfig: Xla_PaddingConfig {
    get {return _storage._paddingConfig ?? Xla_PaddingConfig()}
    set {_uniqueStorage()._paddingConfig = newValue}
  }
  /// Returns true if `paddingConfig` has been explicitly set.
  public var hasPaddingConfig: Bool {return _storage._paddingConfig != nil}
  /// Clears the value of `paddingConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPaddingConfig() {_uniqueStorage()._paddingConfig = nil}

  /// Outfeed configuration information, only present for kOutfeed.
  public var outfeedConfig: Data {
    get {return _storage._outfeedConfig}
    set {_uniqueStorage()._outfeedConfig = newValue}
  }

  /// The distribution requested for random number generation.
  /// Only present for kRng.
  public var distribution: Xla_RandomDistribution {
    get {return _storage._distribution}
    set {_uniqueStorage()._distribution = newValue}
  }

  /// A small float number added to the variance to avoid divide-by-zero error.
  /// Only present for kBatchNormTraining.
  public var epsilon: Float {
    get {return _storage._epsilon}
    set {_uniqueStorage()._epsilon = newValue}
  }

  /// An integer value representing the index of the feature dimension.
  /// Only present for kBatchNormTraining.
  public var featureIndex: Int64 {
    get {return _storage._featureIndex}
    set {_uniqueStorage()._featureIndex = newValue}
  }

  /// Represents a unique identifier for each Send/Recv instruction pair.
  /// Only present for kSend or kRecv.
  public var channelID: Int64 {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// The string representation of the infeed configuration.
  public var infeedConfig: Data {
    get {return _storage._infeedConfig}
    set {_uniqueStorage()._infeedConfig = newValue}
  }

  /// Name of a external target (eg, global symbol) to call, only present for
  /// kCustomCall.
  public var customCallTarget: String {
    get {return _storage._customCallTarget}
    set {_uniqueStorage()._customCallTarget = newValue}
  }

  /// Opaque string, only present for kCustomCall.
  public var customCallOpaque: String {
    get {return _storage._customCallOpaque}
    set {_uniqueStorage()._customCallOpaque = newValue}
  }

  /// Shape of outfeed request.
  public var outfeedShape: Xla_ShapeProto {
    get {return _storage._outfeedShape ?? Xla_ShapeProto()}
    set {_uniqueStorage()._outfeedShape = newValue}
  }
  /// Returns true if `outfeedShape` has been explicitly set.
  public var hasOutfeedShape: Bool {return _storage._outfeedShape != nil}
  /// Clears the value of `outfeedShape`. Subsequent reads from it will return its default value.
  public mutating func clearOutfeedShape() {_uniqueStorage()._outfeedShape = nil}

  /// Describes the dimension numbers used for a dot operation
  public var dotDimensionNumbers: Xla_DotDimensionNumbers {
    get {return _storage._dotDimensionNumbers ?? Xla_DotDimensionNumbers()}
    set {_uniqueStorage()._dotDimensionNumbers = newValue}
  }
  /// Returns true if `dotDimensionNumbers` has been explicitly set.
  public var hasDotDimensionNumbers: Bool {return _storage._dotDimensionNumbers != nil}
  /// Clears the value of `dotDimensionNumbers`. Subsequent reads from it will return its default value.
  public mutating func clearDotDimensionNumbers() {_uniqueStorage()._dotDimensionNumbers = nil}

  /// FFT type (FFT, IFFT, etc).
  public var fftType: Xla_FftType {
    get {return _storage._fftType}
    set {_uniqueStorage()._fftType = newValue}
  }

  /// FFT length.
  public var fftLength: [Int64] {
    get {return _storage._fftLength}
    set {_uniqueStorage()._fftLength = newValue}
  }

  /// Gather dimension numbers.
  public var gatherDimensionNumbers: Xla_GatherDimensionNumbers {
    get {return _storage._gatherDimensionNumbers ?? Xla_GatherDimensionNumbers()}
    set {_uniqueStorage()._gatherDimensionNumbers = newValue}
  }
  /// Returns true if `gatherDimensionNumbers` has been explicitly set.
  public var hasGatherDimensionNumbers: Bool {return _storage._gatherDimensionNumbers != nil}
  /// Clears the value of `gatherDimensionNumbers`. Subsequent reads from it will return its default value.
  public mutating func clearGatherDimensionNumbers() {_uniqueStorage()._gatherDimensionNumbers = nil}

  public var gatherSliceSizes: [Int64] {
    get {return _storage._gatherSliceSizes}
    set {_uniqueStorage()._gatherSliceSizes = newValue}
  }

  /// Compute Host.
  public var channelName: String {
    get {return _storage._channelName}
    set {_uniqueStorage()._channelName = newValue}
  }

  public var costEstimateNs: Int64 {
    get {return _storage._costEstimateNs}
    set {_uniqueStorage()._costEstimateNs = newValue}
  }

  /// The id of this instruction.
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var operandIds: [Int64] {
    get {return _storage._operandIds}
    set {_uniqueStorage()._operandIds = newValue}
  }

  public var controlPredecessorIds: [Int64] {
    get {return _storage._controlPredecessorIds}
    set {_uniqueStorage()._controlPredecessorIds = newValue}
  }

  public var calledComputationIds: [Int64] {
    get {return _storage._calledComputationIds}
    set {_uniqueStorage()._calledComputationIds = newValue}
  }

  public var sharding: Xla_OpSharding {
    get {return _storage._sharding ?? Xla_OpSharding()}
    set {_uniqueStorage()._sharding = newValue}
  }
  /// Returns true if `sharding` has been explicitly set.
  public var hasSharding: Bool {return _storage._sharding != nil}
  /// Clears the value of `sharding`. Subsequent reads from it will return its default value.
  public mutating func clearSharding() {_uniqueStorage()._sharding = nil}

  /// Backend configuration for the instruction. Has backend-specific meaning.
  public var backendConfig: String {
    get {return _storage._backendConfig}
    set {_uniqueStorage()._backendConfig = newValue}
  }

  /// Cross replica op fields.
  public var replicaGroups: [Xla_ReplicaGroup] {
    get {return _storage._replicaGroups}
    set {_uniqueStorage()._replicaGroups = newValue}
  }

  public var allReduceID: Int64 {
    get {return _storage._allReduceID}
    set {_uniqueStorage()._allReduceID = newValue}
  }

  public var allReduceBarrier: String {
    get {return _storage._allReduceBarrier}
    set {_uniqueStorage()._allReduceBarrier = newValue}
  }

  /// Whether this Send/Recv instruction transfers data to/from the host. Only
  /// present for Send and Recv instructions and their SendDone and RecvDone
  /// partners.
  public var isHostTransfer: Bool {
    get {return _storage._isHostTransfer}
    set {_uniqueStorage()._isHostTransfer = newValue}
  }

  public var scatterDimensionNumbers: Xla_ScatterDimensionNumbers {
    get {return _storage._scatterDimensionNumbers ?? Xla_ScatterDimensionNumbers()}
    set {_uniqueStorage()._scatterDimensionNumbers = newValue}
  }
  /// Returns true if `scatterDimensionNumbers` has been explicitly set.
  public var hasScatterDimensionNumbers: Bool {return _storage._scatterDimensionNumbers != nil}
  /// Clears the value of `scatterDimensionNumbers`. Subsequent reads from it will return its default value.
  public mutating func clearScatterDimensionNumbers() {_uniqueStorage()._scatterDimensionNumbers = nil}

  /// Precision configuration for the instruction. Has backend-specific meaning.
  public var precisionConfig: Xla_PrecisionConfig {
    get {return _storage._precisionConfig ?? Xla_PrecisionConfig()}
    set {_uniqueStorage()._precisionConfig = newValue}
  }
  /// Returns true if `precisionConfig` has been explicitly set.
  public var hasPrecisionConfig: Bool {return _storage._precisionConfig != nil}
  /// Clears the value of `precisionConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPrecisionConfig() {_uniqueStorage()._precisionConfig = nil}

  /// Collective permute field.
  public var sourceTargetPairs: [Xla_SourceTarget] {
    get {return _storage._sourceTargetPairs}
    set {_uniqueStorage()._sourceTargetPairs = newValue}
  }

  /// Sharding for kDomain instructions.
  public var domainEntrySharding: Xla_OpSharding {
    get {return _storage._domainEntrySharding ?? Xla_OpSharding()}
    set {_uniqueStorage()._domainEntrySharding = newValue}
  }
  /// Returns true if `domainEntrySharding` has been explicitly set.
  public var hasDomainEntrySharding: Bool {return _storage._domainEntrySharding != nil}
  /// Clears the value of `domainEntrySharding`. Subsequent reads from it will return its default value.
  public mutating func clearDomainEntrySharding() {_uniqueStorage()._domainEntrySharding = nil}

  public var domainExitSharding: Xla_OpSharding {
    get {return _storage._domainExitSharding ?? Xla_OpSharding()}
    set {_uniqueStorage()._domainExitSharding = newValue}
  }
  /// Returns true if `domainExitSharding` has been explicitly set.
  public var hasDomainExitSharding: Bool {return _storage._domainExitSharding != nil}
  /// Clears the value of `domainExitSharding`. Subsequent reads from it will return its default value.
  public mutating func clearDomainExitSharding() {_uniqueStorage()._domainExitSharding = nil}

  /// For custom call this indicates that the layouts are constrained. If
  /// constrain_layout is true then the 'shape' field must contain a layout, and
  /// 'operand_shapes_with_layout' must contain a shape with layout for each
  /// operand.
  public var constrainLayout: Bool {
    get {return _storage._constrainLayout}
    set {_uniqueStorage()._constrainLayout = newValue}
  }

  public var operandShapesWithLayout: [Xla_ShapeProto] {
    get {return _storage._operandShapesWithLayout}
    set {_uniqueStorage()._operandShapesWithLayout = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the [begin, end) index range and stride for slices.
  public struct SliceDimensions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var start: Int64 = 0

    public var limit: Int64 = 0

    public var stride: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Serialization of HloComputation.
public struct Xla_HloComputationProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The array of instructions is always in a valid dependency order, where
  /// operands appear before their users.
  public var instructions: [Xla_HloInstructionProto] {
    get {return _storage._instructions}
    set {_uniqueStorage()._instructions = newValue}
  }

  public var programShape: Xla_ProgramShapeProto {
    get {return _storage._programShape ?? Xla_ProgramShapeProto()}
    set {_uniqueStorage()._programShape = newValue}
  }
  /// Returns true if `programShape` has been explicitly set.
  public var hasProgramShape: Bool {return _storage._programShape != nil}
  /// Clears the value of `programShape`. Subsequent reads from it will return its default value.
  public mutating func clearProgramShape() {_uniqueStorage()._programShape = nil}

  /// The id of this computation.
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The id of the root of the computation.
  public var rootID: Int64 {
    get {return _storage._rootID}
    set {_uniqueStorage()._rootID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Serialization of an HLO schedule. An HLO schedule contains a total order of
/// instructions for each non-fusion computation in the module.
public struct Xla_HloScheduleProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map from computation id to sequence.
  public var sequences: Dictionary<Int64,Xla_HloScheduleProto.InstructionSequence> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct InstructionSequence {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var instructionIds: [Int64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Xla_HloInputOutputAliasProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entries: [Xla_HloInputOutputAliasProto.AliasEntryProto] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Kind: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Define a UNDEFINED_ALIAS equal to zero to get around the default-0 proto3
    /// behavior and missing has_*() APIs.
    case undefinedAlias // = 0

    /// An alias setup by the user as must alias. A use setting USER_ALIAS is
    /// expecting the designed output to be dropped over the given input
    /// parameter number+index.
    case userAlias // = 1

    /// An alias setup by the compiler as part of its optimizations.
    case systemAlias // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .undefinedAlias
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefinedAlias
      case 1: self = .userAlias
      case 2: self = .systemAlias
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .undefinedAlias: return 0
      case .userAlias: return 1
      case .systemAlias: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The following proto describes a pair of aliased an input
  /// (described by parameter number and a ShapeIndex of the parameter)
  /// and an output (described by a ShapeIndex of the root
  /// instruction). For example:
  ///
  /// entry = {
  ///  output_shape_index={1},
  ///  parameter_number=0,
  ///  parameter_shape_index={1, 2},
  /// }
  ///
  /// This entry indicates that the first paremter's {1, 2} element is
  /// aliased with the {1} element of the root instruction.
  public struct AliasEntryProto {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ShapeIndex of the root hlo.
    public var outputShapeIndex: [Int64] = []

    /// Number of the parameter in entry computation.
    public var parameterNumber: Int64 = 0

    /// ShapeIndex of the parameter instruction.
    public var parameterShapeIndex: [Int64] = []

    /// The kind of alias to be setup.
    public var kind: Xla_HloInputOutputAliasProto.Kind = .undefinedAlias

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Xla_HloInputOutputAliasProto.Kind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Xla_HloInputOutputAliasProto.Kind] = [
    .undefinedAlias,
    .userAlias,
    .systemAlias,
  ]
}

#endif  // swift(>=4.2)

public struct Xla_DynamicParameterBindingProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entries: [Xla_DynamicParameterBindingProto.Binding] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A list of bindings which indicates that the `target_dim_num` in
  /// the subshape `target_param_index` of parameter `target_param_num`
  /// is a dynamic dimension and its real dynamic size is represented
  /// by `dynamic_param_index` in parameter `dynamic_param_num`.
  ///
  /// As an example, imagine we have a program:
  ///
  /// ENTRY main {
  ///   a = f32[] parameter(0)
  ///   b = f32[10] parameter(1)
  ///   ROOT root = (f32[], f32[10]) tuple(%a, %b)
  /// }
  ///
  /// Let's say 'b' (param index 1) is a dynamic shape whose input has
  /// an upperbound of 10 and real size is determined at runtime.'a'
  /// represents the real size of b's first dimension.
  ///
  /// In this case, the fields are set in the following way:
  /// dynamic_param_num = 1
  /// dynamic_param_index = {}
  /// target_param_num = 0
  /// target_param_index = {}
  /// target_param_dim = 0
  public struct Binding {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var dynamicParamNum: Int64 = 0

    public var dynamicParamIndex: [Int64] = []

    public var targetParamNum: Int64 = 0

    public var targetParamIndex: [Int64] = []

    public var targetParamDimNum: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Serialization of HloModule.
public struct Xla_HloModuleProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var entryComputationName: String {
    get {return _storage._entryComputationName}
    set {_uniqueStorage()._entryComputationName = newValue}
  }

  public var entryComputationID: Int64 {
    get {return _storage._entryComputationID}
    set {_uniqueStorage()._entryComputationID = newValue}
  }

  /// The array of computations is always in a valid dependency order, where
  /// callees appear before their callers.
  public var computations: [Xla_HloComputationProto] {
    get {return _storage._computations}
    set {_uniqueStorage()._computations = newValue}
  }

  /// The host program shape (with layout) of the entry computation.
  public var hostProgramShape: Xla_ProgramShapeProto {
    get {return _storage._hostProgramShape ?? Xla_ProgramShapeProto()}
    set {_uniqueStorage()._hostProgramShape = newValue}
  }
  /// Returns true if `hostProgramShape` has been explicitly set.
  public var hasHostProgramShape: Bool {return _storage._hostProgramShape != nil}
  /// Clears the value of `hostProgramShape`. Subsequent reads from it will return its default value.
  public mutating func clearHostProgramShape() {_uniqueStorage()._hostProgramShape = nil}

  /// The id of this module.
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The schedule for this module.
  public var schedule: Xla_HloScheduleProto {
    get {return _storage._schedule ?? Xla_HloScheduleProto()}
    set {_uniqueStorage()._schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  public var hasSchedule: Bool {return _storage._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  public mutating func clearSchedule() {_uniqueStorage()._schedule = nil}

  /// Describes alias information between inputs and outputs.
  public var inputOutputAlias: Xla_HloInputOutputAliasProto {
    get {return _storage._inputOutputAlias ?? Xla_HloInputOutputAliasProto()}
    set {_uniqueStorage()._inputOutputAlias = newValue}
  }
  /// Returns true if `inputOutputAlias` has been explicitly set.
  public var hasInputOutputAlias: Bool {return _storage._inputOutputAlias != nil}
  /// Clears the value of `inputOutputAlias`. Subsequent reads from it will return its default value.
  public mutating func clearInputOutputAlias() {_uniqueStorage()._inputOutputAlias = nil}

  public var dynamicParameterBinding: Xla_DynamicParameterBindingProto {
    get {return _storage._dynamicParameterBinding ?? Xla_DynamicParameterBindingProto()}
    set {_uniqueStorage()._dynamicParameterBinding = newValue}
  }
  /// Returns true if `dynamicParameterBinding` has been explicitly set.
  public var hasDynamicParameterBinding: Bool {return _storage._dynamicParameterBinding != nil}
  /// Clears the value of `dynamicParameterBinding`. Subsequent reads from it will return its default value.
  public mutating func clearDynamicParameterBinding() {_uniqueStorage()._dynamicParameterBinding = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Serialization of LogicalBuffer.
public struct Xla_LogicalBufferProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var size: Int64 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  /// The location where the buffer is defined.
  public var definedAt: Xla_LogicalBufferProto.Location {
    get {return _storage._definedAt ?? Xla_LogicalBufferProto.Location()}
    set {_uniqueStorage()._definedAt = newValue}
  }
  /// Returns true if `definedAt` has been explicitly set.
  public var hasDefinedAt: Bool {return _storage._definedAt != nil}
  /// Clears the value of `definedAt`. Subsequent reads from it will return its default value.
  public mutating func clearDefinedAt() {_uniqueStorage()._definedAt = nil}

  public var color: Int64 {
    get {return _storage._color}
    set {_uniqueStorage()._color = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Location represents an instruction and its shape index, which uniquely
  /// identifies a point where a buffer is needed.
  public struct Location {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// NOTE: module_name isn't necessary, since all LogicalBuffers are
    /// associated with a single HloModule.
    public var computationName: String = String()

    public var instructionName: String = String()

    public var shapeIndex: [Int64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Serialization of BufferAllocation.
public struct Xla_BufferAllocationProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: Int64 = 0

  public var size: Int64 = 0

  public var isThreadLocal: Bool = false

  public var isTuple: Bool = false

  public var isEntryComputationParameter: Bool = false

  public var isConstant: Bool = false

  public var parameterNumber: Int64 = 0

  public var parameterShapeIndex: [Int64] = []

  public var maybeLiveOut: Bool = false

  public var color: Int64 = 0

  public var assigned: [Xla_BufferAllocationProto.Assigned] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Assigned represents a single LogicalBuffer that is assigned to this
  /// BufferAllocation.
  public struct Assigned {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var logicalBufferID: Int64 = 0

    public var offset: Int64 = 0

    public var size: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A trace of a HeapSimulator run.
public struct Xla_HeapSimulatorTrace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [Xla_HeapSimulatorTrace.Event] = []

  public var wholeModuleSimulation: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The trace includes a list of events, where each event describes one action
  /// performed by the heap simulator.
  public struct Event {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: Xla_HeapSimulatorTrace.Event.Kind = .alloc

    /// The id of the LogicalBuffer that the event applies to.
    public var bufferID: Int64 = 0

    /// The HloInstruction that the simulation was processing that caused this
    /// event to occur, identified by its computation and instruction name. E.g.
    /// buffers defined by instruction A are allocated when processing A.
    public var computationName: String = String()

    public var instructionName: String = String()

    /// The id of the canonical LogicalBuffer that the buffer shares with. Only
    /// set for SHARE_WITH events.
    public var shareWithCanonicalID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Kind: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// A memory region was allocated for the buffer.
      case alloc // = 0

      /// A memory region was freed for the buffer.
      case free // = 1

      /// A buffer was shared with another (canonical) buffer. This is similar to
      /// ALLOC, except that instead of allocating a new region of memory, the
      /// memory region of the canonical buffer is directly re-used. Multiple
      /// buffers may share with the same canonical buffer. The lifetime of the
      /// canonical buffer is extended to the union of all lifetimes.
      case shareWith // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .alloc
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .alloc
        case 1: self = .free
        case 2: self = .shareWith
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .alloc: return 0
        case .free: return 1
        case .shareWith: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

/// An abstraction representing a set of HLO module built to run concurrently
/// across different devices.
public struct Xla_HloModuleGroupProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var hloModules: [Xla_HloModuleProto] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Serialization of BufferAssignment.
public struct Xla_BufferAssignmentProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var logicalBuffers: [Xla_LogicalBufferProto] = []

  public var bufferAliases: [Xla_BufferAssignmentProto.BufferAlias] = []

  public var bufferAllocations: [Xla_BufferAllocationProto] = []

  public var heapSimulatorTraces: [Xla_HeapSimulatorTrace] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Alias represents a source LogicalBuffer, and the buffer location that
  /// aliases it.
  public struct BufferAlias {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sourceBufferID: Int64 {
      get {return _storage._sourceBufferID}
      set {_uniqueStorage()._sourceBufferID = newValue}
    }

    public var location: Xla_LogicalBufferProto.Location {
      get {return _storage._location ?? Xla_LogicalBufferProto.Location()}
      set {_uniqueStorage()._location = newValue}
    }
    /// Returns true if `location` has been explicitly set.
    public var hasLocation: Bool {return _storage._location != nil}
    /// Clears the value of `location`. Subsequent reads from it will return its default value.
    public mutating func clearLocation() {_uniqueStorage()._location = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Grouping message that contains all of the information above.
public struct Xla_HloProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hloModule: Xla_HloModuleProto {
    get {return _storage._hloModule ?? Xla_HloModuleProto()}
    set {_uniqueStorage()._hloModule = newValue}
  }
  /// Returns true if `hloModule` has been explicitly set.
  public var hasHloModule: Bool {return _storage._hloModule != nil}
  /// Clears the value of `hloModule`. Subsequent reads from it will return its default value.
  public mutating func clearHloModule() {_uniqueStorage()._hloModule = nil}

  public var bufferAssignment: Xla_BufferAssignmentProto {
    get {return _storage._bufferAssignment ?? Xla_BufferAssignmentProto()}
    set {_uniqueStorage()._bufferAssignment = newValue}
  }
  /// Returns true if `bufferAssignment` has been explicitly set.
  public var hasBufferAssignment: Bool {return _storage._bufferAssignment != nil}
  /// Clears the value of `bufferAssignment`. Subsequent reads from it will return its default value.
  public mutating func clearBufferAssignment() {_uniqueStorage()._bufferAssignment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Encapsulates HloProto together with the arguments, result, and
/// execution_platform. This message is used for purposes such as
/// analysis/replay/file-storage.
public struct Xla_HloSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hlo graph.
  public var hlo: Xla_HloProto {
    get {return _storage._hlo ?? Xla_HloProto()}
    set {_uniqueStorage()._hlo = newValue}
  }
  /// Returns true if `hlo` has been explicitly set.
  public var hasHlo: Bool {return _storage._hlo != nil}
  /// Clears the value of `hlo`. Subsequent reads from it will return its default value.
  public mutating func clearHlo() {_uniqueStorage()._hlo = nil}

  /// The arguments passed to the graph.
  public var arguments: [Xla_LiteralProto] {
    get {return _storage._arguments}
    set {_uniqueStorage()._arguments = newValue}
  }

  /// The result of the graph.
  public var result: Xla_LiteralProto {
    get {return _storage._result ?? Xla_LiteralProto()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {_uniqueStorage()._result = nil}

  /// The name of the platform used to run the graph.
  public var executionPlatform: String {
    get {return _storage._executionPlatform}
    set {_uniqueStorage()._executionPlatform = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xla"

extension Xla_HloInstructionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloInstructionProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "opcode"),
    3: .same(proto: "shape"),
    7: .same(proto: "metadata"),
    8: .same(proto: "literal"),
    9: .standard(proto: "parameter_number"),
    11: .standard(proto: "fusion_kind"),
    13: .standard(proto: "tuple_index"),
    14: .same(proto: "dimensions"),
    15: .same(proto: "window"),
    16: .standard(proto: "convolution_dimension_numbers"),
    50: .standard(proto: "feature_group_count"),
    58: .standard(proto: "batch_group_count"),
    17: .standard(proto: "slice_dimensions"),
    18: .standard(proto: "exponent_bits"),
    19: .standard(proto: "mantissa_bits"),
    20: .standard(proto: "dynamic_slice_sizes"),
    21: .standard(proto: "padding_config"),
    22: .standard(proto: "outfeed_config"),
    23: .same(proto: "distribution"),
    24: .same(proto: "epsilon"),
    25: .standard(proto: "feature_index"),
    26: .standard(proto: "channel_id"),
    27: .standard(proto: "infeed_config"),
    28: .standard(proto: "custom_call_target"),
    53: .standard(proto: "custom_call_opaque"),
    29: .standard(proto: "outfeed_shape"),
    30: .standard(proto: "dot_dimension_numbers"),
    31: .standard(proto: "fft_type"),
    32: .standard(proto: "fft_length"),
    33: .standard(proto: "gather_dimension_numbers"),
    34: .standard(proto: "gather_slice_sizes"),
    41: .standard(proto: "channel_name"),
    42: .standard(proto: "cost_estimate_ns"),
    35: .same(proto: "id"),
    36: .standard(proto: "operand_ids"),
    37: .standard(proto: "control_predecessor_ids"),
    38: .standard(proto: "called_computation_ids"),
    40: .same(proto: "sharding"),
    43: .standard(proto: "backend_config"),
    49: .standard(proto: "replica_groups"),
    45: .standard(proto: "all_reduce_id"),
    46: .standard(proto: "all_reduce_barrier"),
    47: .standard(proto: "is_host_transfer"),
    48: .standard(proto: "scatter_dimension_numbers"),
    51: .standard(proto: "precision_config"),
    52: .standard(proto: "source_target_pairs"),
    54: .standard(proto: "domain_entry_sharding"),
    55: .standard(proto: "domain_exit_sharding"),
    56: .standard(proto: "constrain_layout"),
    57: .standard(proto: "operand_shapes_with_layout"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _opcode: String = String()
    var _shape: Xla_ShapeProto? = nil
    var _metadata: Xla_OpMetadata? = nil
    var _literal: Xla_LiteralProto? = nil
    var _parameterNumber: Int64 = 0
    var _fusionKind: String = String()
    var _tupleIndex: Int64 = 0
    var _dimensions: [Int64] = []
    var _window: Xla_Window? = nil
    var _convolutionDimensionNumbers: Xla_ConvolutionDimensionNumbers? = nil
    var _featureGroupCount: Int64 = 0
    var _batchGroupCount: Int64 = 0
    var _sliceDimensions: [Xla_HloInstructionProto.SliceDimensions] = []
    var _exponentBits: Int32 = 0
    var _mantissaBits: Int32 = 0
    var _dynamicSliceSizes: [Int64] = []
    var _paddingConfig: Xla_PaddingConfig? = nil
    var _outfeedConfig: Data = SwiftProtobuf.Internal.emptyData
    var _distribution: Xla_RandomDistribution = .rngInvalid
    var _epsilon: Float = 0
    var _featureIndex: Int64 = 0
    var _channelID: Int64 = 0
    var _infeedConfig: Data = SwiftProtobuf.Internal.emptyData
    var _customCallTarget: String = String()
    var _customCallOpaque: String = String()
    var _outfeedShape: Xla_ShapeProto? = nil
    var _dotDimensionNumbers: Xla_DotDimensionNumbers? = nil
    var _fftType: Xla_FftType = .fft
    var _fftLength: [Int64] = []
    var _gatherDimensionNumbers: Xla_GatherDimensionNumbers? = nil
    var _gatherSliceSizes: [Int64] = []
    var _channelName: String = String()
    var _costEstimateNs: Int64 = 0
    var _id: Int64 = 0
    var _operandIds: [Int64] = []
    var _controlPredecessorIds: [Int64] = []
    var _calledComputationIds: [Int64] = []
    var _sharding: Xla_OpSharding? = nil
    var _backendConfig: String = String()
    var _replicaGroups: [Xla_ReplicaGroup] = []
    var _allReduceID: Int64 = 0
    var _allReduceBarrier: String = String()
    var _isHostTransfer: Bool = false
    var _scatterDimensionNumbers: Xla_ScatterDimensionNumbers? = nil
    var _precisionConfig: Xla_PrecisionConfig? = nil
    var _sourceTargetPairs: [Xla_SourceTarget] = []
    var _domainEntrySharding: Xla_OpSharding? = nil
    var _domainExitSharding: Xla_OpSharding? = nil
    var _constrainLayout: Bool = false
    var _operandShapesWithLayout: [Xla_ShapeProto] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _opcode = source._opcode
      _shape = source._shape
      _metadata = source._metadata
      _literal = source._literal
      _parameterNumber = source._parameterNumber
      _fusionKind = source._fusionKind
      _tupleIndex = source._tupleIndex
      _dimensions = source._dimensions
      _window = source._window
      _convolutionDimensionNumbers = source._convolutionDimensionNumbers
      _featureGroupCount = source._featureGroupCount
      _batchGroupCount = source._batchGroupCount
      _sliceDimensions = source._sliceDimensions
      _exponentBits = source._exponentBits
      _mantissaBits = source._mantissaBits
      _dynamicSliceSizes = source._dynamicSliceSizes
      _paddingConfig = source._paddingConfig
      _outfeedConfig = source._outfeedConfig
      _distribution = source._distribution
      _epsilon = source._epsilon
      _featureIndex = source._featureIndex
      _channelID = source._channelID
      _infeedConfig = source._infeedConfig
      _customCallTarget = source._customCallTarget
      _customCallOpaque = source._customCallOpaque
      _outfeedShape = source._outfeedShape
      _dotDimensionNumbers = source._dotDimensionNumbers
      _fftType = source._fftType
      _fftLength = source._fftLength
      _gatherDimensionNumbers = source._gatherDimensionNumbers
      _gatherSliceSizes = source._gatherSliceSizes
      _channelName = source._channelName
      _costEstimateNs = source._costEstimateNs
      _id = source._id
      _operandIds = source._operandIds
      _controlPredecessorIds = source._controlPredecessorIds
      _calledComputationIds = source._calledComputationIds
      _sharding = source._sharding
      _backendConfig = source._backendConfig
      _replicaGroups = source._replicaGroups
      _allReduceID = source._allReduceID
      _allReduceBarrier = source._allReduceBarrier
      _isHostTransfer = source._isHostTransfer
      _scatterDimensionNumbers = source._scatterDimensionNumbers
      _precisionConfig = source._precisionConfig
      _sourceTargetPairs = source._sourceTargetPairs
      _domainEntrySharding = source._domainEntrySharding
      _domainExitSharding = source._domainExitSharding
      _constrainLayout = source._constrainLayout
      _operandShapesWithLayout = source._operandShapesWithLayout
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._opcode)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._shape)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._literal)
        case 9: try decoder.decodeSingularInt64Field(value: &_storage._parameterNumber)
        case 11: try decoder.decodeSingularStringField(value: &_storage._fusionKind)
        case 13: try decoder.decodeSingularInt64Field(value: &_storage._tupleIndex)
        case 14: try decoder.decodeRepeatedInt64Field(value: &_storage._dimensions)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._window)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._convolutionDimensionNumbers)
        case 17: try decoder.decodeRepeatedMessageField(value: &_storage._sliceDimensions)
        case 18: try decoder.decodeSingularInt32Field(value: &_storage._exponentBits)
        case 19: try decoder.decodeSingularInt32Field(value: &_storage._mantissaBits)
        case 20: try decoder.decodeRepeatedInt64Field(value: &_storage._dynamicSliceSizes)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._paddingConfig)
        case 22: try decoder.decodeSingularBytesField(value: &_storage._outfeedConfig)
        case 23: try decoder.decodeSingularEnumField(value: &_storage._distribution)
        case 24: try decoder.decodeSingularFloatField(value: &_storage._epsilon)
        case 25: try decoder.decodeSingularInt64Field(value: &_storage._featureIndex)
        case 26: try decoder.decodeSingularInt64Field(value: &_storage._channelID)
        case 27: try decoder.decodeSingularBytesField(value: &_storage._infeedConfig)
        case 28: try decoder.decodeSingularStringField(value: &_storage._customCallTarget)
        case 29: try decoder.decodeSingularMessageField(value: &_storage._outfeedShape)
        case 30: try decoder.decodeSingularMessageField(value: &_storage._dotDimensionNumbers)
        case 31: try decoder.decodeSingularEnumField(value: &_storage._fftType)
        case 32: try decoder.decodeRepeatedInt64Field(value: &_storage._fftLength)
        case 33: try decoder.decodeSingularMessageField(value: &_storage._gatherDimensionNumbers)
        case 34: try decoder.decodeRepeatedInt64Field(value: &_storage._gatherSliceSizes)
        case 35: try decoder.decodeSingularInt64Field(value: &_storage._id)
        case 36: try decoder.decodeRepeatedInt64Field(value: &_storage._operandIds)
        case 37: try decoder.decodeRepeatedInt64Field(value: &_storage._controlPredecessorIds)
        case 38: try decoder.decodeRepeatedInt64Field(value: &_storage._calledComputationIds)
        case 40: try decoder.decodeSingularMessageField(value: &_storage._sharding)
        case 41: try decoder.decodeSingularStringField(value: &_storage._channelName)
        case 42: try decoder.decodeSingularInt64Field(value: &_storage._costEstimateNs)
        case 43: try decoder.decodeSingularStringField(value: &_storage._backendConfig)
        case 45: try decoder.decodeSingularInt64Field(value: &_storage._allReduceID)
        case 46: try decoder.decodeSingularStringField(value: &_storage._allReduceBarrier)
        case 47: try decoder.decodeSingularBoolField(value: &_storage._isHostTransfer)
        case 48: try decoder.decodeSingularMessageField(value: &_storage._scatterDimensionNumbers)
        case 49: try decoder.decodeRepeatedMessageField(value: &_storage._replicaGroups)
        case 50: try decoder.decodeSingularInt64Field(value: &_storage._featureGroupCount)
        case 51: try decoder.decodeSingularMessageField(value: &_storage._precisionConfig)
        case 52: try decoder.decodeRepeatedMessageField(value: &_storage._sourceTargetPairs)
        case 53: try decoder.decodeSingularStringField(value: &_storage._customCallOpaque)
        case 54: try decoder.decodeSingularMessageField(value: &_storage._domainEntrySharding)
        case 55: try decoder.decodeSingularMessageField(value: &_storage._domainExitSharding)
        case 56: try decoder.decodeSingularBoolField(value: &_storage._constrainLayout)
        case 57: try decoder.decodeRepeatedMessageField(value: &_storage._operandShapesWithLayout)
        case 58: try decoder.decodeSingularInt64Field(value: &_storage._batchGroupCount)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._opcode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._opcode, fieldNumber: 2)
      }
      if let v = _storage._shape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._literal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._parameterNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._parameterNumber, fieldNumber: 9)
      }
      if !_storage._fusionKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fusionKind, fieldNumber: 11)
      }
      if _storage._tupleIndex != 0 {
        try visitor.visitSingularInt64Field(value: _storage._tupleIndex, fieldNumber: 13)
      }
      if !_storage._dimensions.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._dimensions, fieldNumber: 14)
      }
      if let v = _storage._window {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._convolutionDimensionNumbers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._sliceDimensions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sliceDimensions, fieldNumber: 17)
      }
      if _storage._exponentBits != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exponentBits, fieldNumber: 18)
      }
      if _storage._mantissaBits != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mantissaBits, fieldNumber: 19)
      }
      if !_storage._dynamicSliceSizes.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._dynamicSliceSizes, fieldNumber: 20)
      }
      if let v = _storage._paddingConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if !_storage._outfeedConfig.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._outfeedConfig, fieldNumber: 22)
      }
      if _storage._distribution != .rngInvalid {
        try visitor.visitSingularEnumField(value: _storage._distribution, fieldNumber: 23)
      }
      if _storage._epsilon != 0 {
        try visitor.visitSingularFloatField(value: _storage._epsilon, fieldNumber: 24)
      }
      if _storage._featureIndex != 0 {
        try visitor.visitSingularInt64Field(value: _storage._featureIndex, fieldNumber: 25)
      }
      if _storage._channelID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._channelID, fieldNumber: 26)
      }
      if !_storage._infeedConfig.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._infeedConfig, fieldNumber: 27)
      }
      if !_storage._customCallTarget.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customCallTarget, fieldNumber: 28)
      }
      if let v = _storage._outfeedShape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }
      if let v = _storage._dotDimensionNumbers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if _storage._fftType != .fft {
        try visitor.visitSingularEnumField(value: _storage._fftType, fieldNumber: 31)
      }
      if !_storage._fftLength.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._fftLength, fieldNumber: 32)
      }
      if let v = _storage._gatherDimensionNumbers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }
      if !_storage._gatherSliceSizes.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._gatherSliceSizes, fieldNumber: 34)
      }
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 35)
      }
      if !_storage._operandIds.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._operandIds, fieldNumber: 36)
      }
      if !_storage._controlPredecessorIds.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._controlPredecessorIds, fieldNumber: 37)
      }
      if !_storage._calledComputationIds.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._calledComputationIds, fieldNumber: 38)
      }
      if let v = _storage._sharding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }
      if !_storage._channelName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelName, fieldNumber: 41)
      }
      if _storage._costEstimateNs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._costEstimateNs, fieldNumber: 42)
      }
      if !_storage._backendConfig.isEmpty {
        try visitor.visitSingularStringField(value: _storage._backendConfig, fieldNumber: 43)
      }
      if _storage._allReduceID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._allReduceID, fieldNumber: 45)
      }
      if !_storage._allReduceBarrier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._allReduceBarrier, fieldNumber: 46)
      }
      if _storage._isHostTransfer != false {
        try visitor.visitSingularBoolField(value: _storage._isHostTransfer, fieldNumber: 47)
      }
      if let v = _storage._scatterDimensionNumbers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }
      if !_storage._replicaGroups.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._replicaGroups, fieldNumber: 49)
      }
      if _storage._featureGroupCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._featureGroupCount, fieldNumber: 50)
      }
      if let v = _storage._precisionConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }
      if !_storage._sourceTargetPairs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sourceTargetPairs, fieldNumber: 52)
      }
      if !_storage._customCallOpaque.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customCallOpaque, fieldNumber: 53)
      }
      if let v = _storage._domainEntrySharding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      }
      if let v = _storage._domainExitSharding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      }
      if _storage._constrainLayout != false {
        try visitor.visitSingularBoolField(value: _storage._constrainLayout, fieldNumber: 56)
      }
      if !_storage._operandShapesWithLayout.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._operandShapesWithLayout, fieldNumber: 57)
      }
      if _storage._batchGroupCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._batchGroupCount, fieldNumber: 58)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HloInstructionProto, rhs: Xla_HloInstructionProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._opcode != rhs_storage._opcode {return false}
        if _storage._shape != rhs_storage._shape {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._literal != rhs_storage._literal {return false}
        if _storage._parameterNumber != rhs_storage._parameterNumber {return false}
        if _storage._fusionKind != rhs_storage._fusionKind {return false}
        if _storage._tupleIndex != rhs_storage._tupleIndex {return false}
        if _storage._dimensions != rhs_storage._dimensions {return false}
        if _storage._window != rhs_storage._window {return false}
        if _storage._convolutionDimensionNumbers != rhs_storage._convolutionDimensionNumbers {return false}
        if _storage._featureGroupCount != rhs_storage._featureGroupCount {return false}
        if _storage._batchGroupCount != rhs_storage._batchGroupCount {return false}
        if _storage._sliceDimensions != rhs_storage._sliceDimensions {return false}
        if _storage._exponentBits != rhs_storage._exponentBits {return false}
        if _storage._mantissaBits != rhs_storage._mantissaBits {return false}
        if _storage._dynamicSliceSizes != rhs_storage._dynamicSliceSizes {return false}
        if _storage._paddingConfig != rhs_storage._paddingConfig {return false}
        if _storage._outfeedConfig != rhs_storage._outfeedConfig {return false}
        if _storage._distribution != rhs_storage._distribution {return false}
        if _storage._epsilon != rhs_storage._epsilon {return false}
        if _storage._featureIndex != rhs_storage._featureIndex {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._infeedConfig != rhs_storage._infeedConfig {return false}
        if _storage._customCallTarget != rhs_storage._customCallTarget {return false}
        if _storage._customCallOpaque != rhs_storage._customCallOpaque {return false}
        if _storage._outfeedShape != rhs_storage._outfeedShape {return false}
        if _storage._dotDimensionNumbers != rhs_storage._dotDimensionNumbers {return false}
        if _storage._fftType != rhs_storage._fftType {return false}
        if _storage._fftLength != rhs_storage._fftLength {return false}
        if _storage._gatherDimensionNumbers != rhs_storage._gatherDimensionNumbers {return false}
        if _storage._gatherSliceSizes != rhs_storage._gatherSliceSizes {return false}
        if _storage._channelName != rhs_storage._channelName {return false}
        if _storage._costEstimateNs != rhs_storage._costEstimateNs {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._operandIds != rhs_storage._operandIds {return false}
        if _storage._controlPredecessorIds != rhs_storage._controlPredecessorIds {return false}
        if _storage._calledComputationIds != rhs_storage._calledComputationIds {return false}
        if _storage._sharding != rhs_storage._sharding {return false}
        if _storage._backendConfig != rhs_storage._backendConfig {return false}
        if _storage._replicaGroups != rhs_storage._replicaGroups {return false}
        if _storage._allReduceID != rhs_storage._allReduceID {return false}
        if _storage._allReduceBarrier != rhs_storage._allReduceBarrier {return false}
        if _storage._isHostTransfer != rhs_storage._isHostTransfer {return false}
        if _storage._scatterDimensionNumbers != rhs_storage._scatterDimensionNumbers {return false}
        if _storage._precisionConfig != rhs_storage._precisionConfig {return false}
        if _storage._sourceTargetPairs != rhs_storage._sourceTargetPairs {return false}
        if _storage._domainEntrySharding != rhs_storage._domainEntrySharding {return false}
        if _storage._domainExitSharding != rhs_storage._domainExitSharding {return false}
        if _storage._constrainLayout != rhs_storage._constrainLayout {return false}
        if _storage._operandShapesWithLayout != rhs_storage._operandShapesWithLayout {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HloInstructionProto.SliceDimensions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_HloInstructionProto.protoMessageName + ".SliceDimensions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "limit"),
    3: .same(proto: "stride"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.start)
      case 2: try decoder.decodeSingularInt64Field(value: &self.limit)
      case 3: try decoder.decodeSingularInt64Field(value: &self.stride)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 2)
    }
    if self.stride != 0 {
      try visitor.visitSingularInt64Field(value: self.stride, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HloInstructionProto.SliceDimensions, rhs: Xla_HloInstructionProto.SliceDimensions) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.stride != rhs.stride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HloComputationProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloComputationProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "instructions"),
    4: .standard(proto: "program_shape"),
    5: .same(proto: "id"),
    6: .standard(proto: "root_id"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _instructions: [Xla_HloInstructionProto] = []
    var _programShape: Xla_ProgramShapeProto? = nil
    var _id: Int64 = 0
    var _rootID: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _instructions = source._instructions
      _programShape = source._programShape
      _id = source._id
      _rootID = source._rootID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._instructions)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._programShape)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._id)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._rootID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._instructions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._instructions, fieldNumber: 2)
      }
      if let v = _storage._programShape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 5)
      }
      if _storage._rootID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._rootID, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HloComputationProto, rhs: Xla_HloComputationProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._instructions != rhs_storage._instructions {return false}
        if _storage._programShape != rhs_storage._programShape {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._rootID != rhs_storage._rootID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HloScheduleProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloScheduleProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sequences"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Xla_HloScheduleProto.InstructionSequence>.self, value: &self.sequences)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sequences.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Xla_HloScheduleProto.InstructionSequence>.self, value: self.sequences, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HloScheduleProto, rhs: Xla_HloScheduleProto) -> Bool {
    if lhs.sequences != rhs.sequences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HloScheduleProto.InstructionSequence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_HloScheduleProto.protoMessageName + ".InstructionSequence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instruction_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt64Field(value: &self.instructionIds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instructionIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.instructionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HloScheduleProto.InstructionSequence, rhs: Xla_HloScheduleProto.InstructionSequence) -> Bool {
    if lhs.instructionIds != rhs.instructionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HloInputOutputAliasProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloInputOutputAliasProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.entries)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HloInputOutputAliasProto, rhs: Xla_HloInputOutputAliasProto) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HloInputOutputAliasProto.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED_ALIAS"),
    1: .same(proto: "USER_ALIAS"),
    2: .same(proto: "SYSTEM_ALIAS"),
  ]
}

extension Xla_HloInputOutputAliasProto.AliasEntryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_HloInputOutputAliasProto.protoMessageName + ".AliasEntryProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_shape_index"),
    2: .standard(proto: "parameter_number"),
    3: .standard(proto: "parameter_shape_index"),
    4: .same(proto: "kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt64Field(value: &self.outputShapeIndex)
      case 2: try decoder.decodeSingularInt64Field(value: &self.parameterNumber)
      case 3: try decoder.decodeRepeatedInt64Field(value: &self.parameterShapeIndex)
      case 4: try decoder.decodeSingularEnumField(value: &self.kind)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputShapeIndex.isEmpty {
      try visitor.visitPackedInt64Field(value: self.outputShapeIndex, fieldNumber: 1)
    }
    if self.parameterNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.parameterNumber, fieldNumber: 2)
    }
    if !self.parameterShapeIndex.isEmpty {
      try visitor.visitPackedInt64Field(value: self.parameterShapeIndex, fieldNumber: 3)
    }
    if self.kind != .undefinedAlias {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HloInputOutputAliasProto.AliasEntryProto, rhs: Xla_HloInputOutputAliasProto.AliasEntryProto) -> Bool {
    if lhs.outputShapeIndex != rhs.outputShapeIndex {return false}
    if lhs.parameterNumber != rhs.parameterNumber {return false}
    if lhs.parameterShapeIndex != rhs.parameterShapeIndex {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_DynamicParameterBindingProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DynamicParameterBindingProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.entries)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_DynamicParameterBindingProto, rhs: Xla_DynamicParameterBindingProto) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_DynamicParameterBindingProto.Binding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_DynamicParameterBindingProto.protoMessageName + ".Binding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dynamic_param_num"),
    2: .standard(proto: "dynamic_param_index"),
    3: .standard(proto: "target_param_num"),
    4: .standard(proto: "target_param_index"),
    5: .standard(proto: "target_param_dim_num"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.dynamicParamNum)
      case 2: try decoder.decodeRepeatedInt64Field(value: &self.dynamicParamIndex)
      case 3: try decoder.decodeSingularInt64Field(value: &self.targetParamNum)
      case 4: try decoder.decodeRepeatedInt64Field(value: &self.targetParamIndex)
      case 5: try decoder.decodeSingularInt64Field(value: &self.targetParamDimNum)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dynamicParamNum != 0 {
      try visitor.visitSingularInt64Field(value: self.dynamicParamNum, fieldNumber: 1)
    }
    if !self.dynamicParamIndex.isEmpty {
      try visitor.visitPackedInt64Field(value: self.dynamicParamIndex, fieldNumber: 2)
    }
    if self.targetParamNum != 0 {
      try visitor.visitSingularInt64Field(value: self.targetParamNum, fieldNumber: 3)
    }
    if !self.targetParamIndex.isEmpty {
      try visitor.visitPackedInt64Field(value: self.targetParamIndex, fieldNumber: 4)
    }
    if self.targetParamDimNum != 0 {
      try visitor.visitSingularInt64Field(value: self.targetParamDimNum, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_DynamicParameterBindingProto.Binding, rhs: Xla_DynamicParameterBindingProto.Binding) -> Bool {
    if lhs.dynamicParamNum != rhs.dynamicParamNum {return false}
    if lhs.dynamicParamIndex != rhs.dynamicParamIndex {return false}
    if lhs.targetParamNum != rhs.targetParamNum {return false}
    if lhs.targetParamIndex != rhs.targetParamIndex {return false}
    if lhs.targetParamDimNum != rhs.targetParamDimNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HloModuleProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloModuleProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "entry_computation_name"),
    6: .standard(proto: "entry_computation_id"),
    3: .same(proto: "computations"),
    4: .standard(proto: "host_program_shape"),
    5: .same(proto: "id"),
    7: .same(proto: "schedule"),
    8: .standard(proto: "input_output_alias"),
    9: .standard(proto: "dynamic_parameter_binding"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _entryComputationName: String = String()
    var _entryComputationID: Int64 = 0
    var _computations: [Xla_HloComputationProto] = []
    var _hostProgramShape: Xla_ProgramShapeProto? = nil
    var _id: Int64 = 0
    var _schedule: Xla_HloScheduleProto? = nil
    var _inputOutputAlias: Xla_HloInputOutputAliasProto? = nil
    var _dynamicParameterBinding: Xla_DynamicParameterBindingProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _entryComputationName = source._entryComputationName
      _entryComputationID = source._entryComputationID
      _computations = source._computations
      _hostProgramShape = source._hostProgramShape
      _id = source._id
      _schedule = source._schedule
      _inputOutputAlias = source._inputOutputAlias
      _dynamicParameterBinding = source._dynamicParameterBinding
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._entryComputationName)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._computations)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._hostProgramShape)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._id)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._entryComputationID)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._schedule)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._inputOutputAlias)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._dynamicParameterBinding)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._entryComputationName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._entryComputationName, fieldNumber: 2)
      }
      if !_storage._computations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._computations, fieldNumber: 3)
      }
      if let v = _storage._hostProgramShape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 5)
      }
      if _storage._entryComputationID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._entryComputationID, fieldNumber: 6)
      }
      if let v = _storage._schedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._inputOutputAlias {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._dynamicParameterBinding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HloModuleProto, rhs: Xla_HloModuleProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._entryComputationName != rhs_storage._entryComputationName {return false}
        if _storage._entryComputationID != rhs_storage._entryComputationID {return false}
        if _storage._computations != rhs_storage._computations {return false}
        if _storage._hostProgramShape != rhs_storage._hostProgramShape {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._schedule != rhs_storage._schedule {return false}
        if _storage._inputOutputAlias != rhs_storage._inputOutputAlias {return false}
        if _storage._dynamicParameterBinding != rhs_storage._dynamicParameterBinding {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_LogicalBufferProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogicalBufferProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "size"),
    3: .standard(proto: "defined_at"),
    4: .same(proto: "color"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _size: Int64 = 0
    var _definedAt: Xla_LogicalBufferProto.Location? = nil
    var _color: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _size = source._size
      _definedAt = source._definedAt
      _color = source._color
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._id)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._size)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._definedAt)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._color)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._size != 0 {
        try visitor.visitSingularInt64Field(value: _storage._size, fieldNumber: 2)
      }
      if let v = _storage._definedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._color != 0 {
        try visitor.visitSingularInt64Field(value: _storage._color, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_LogicalBufferProto, rhs: Xla_LogicalBufferProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._definedAt != rhs_storage._definedAt {return false}
        if _storage._color != rhs_storage._color {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_LogicalBufferProto.Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_LogicalBufferProto.protoMessageName + ".Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "computation_name"),
    2: .standard(proto: "instruction_name"),
    3: .standard(proto: "shape_index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.computationName)
      case 2: try decoder.decodeSingularStringField(value: &self.instructionName)
      case 3: try decoder.decodeRepeatedInt64Field(value: &self.shapeIndex)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.computationName.isEmpty {
      try visitor.visitSingularStringField(value: self.computationName, fieldNumber: 1)
    }
    if !self.instructionName.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionName, fieldNumber: 2)
    }
    if !self.shapeIndex.isEmpty {
      try visitor.visitPackedInt64Field(value: self.shapeIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_LogicalBufferProto.Location, rhs: Xla_LogicalBufferProto.Location) -> Bool {
    if lhs.computationName != rhs.computationName {return false}
    if lhs.instructionName != rhs.instructionName {return false}
    if lhs.shapeIndex != rhs.shapeIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_BufferAllocationProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BufferAllocationProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "size"),
    3: .standard(proto: "is_thread_local"),
    11: .standard(proto: "is_tuple"),
    5: .standard(proto: "is_entry_computation_parameter"),
    12: .standard(proto: "is_constant"),
    6: .standard(proto: "parameter_number"),
    10: .standard(proto: "parameter_shape_index"),
    7: .standard(proto: "maybe_live_out"),
    8: .same(proto: "color"),
    9: .same(proto: "assigned"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.index)
      case 2: try decoder.decodeSingularInt64Field(value: &self.size)
      case 3: try decoder.decodeSingularBoolField(value: &self.isThreadLocal)
      case 5: try decoder.decodeSingularBoolField(value: &self.isEntryComputationParameter)
      case 6: try decoder.decodeSingularInt64Field(value: &self.parameterNumber)
      case 7: try decoder.decodeSingularBoolField(value: &self.maybeLiveOut)
      case 8: try decoder.decodeSingularInt64Field(value: &self.color)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.assigned)
      case 10: try decoder.decodeRepeatedInt64Field(value: &self.parameterShapeIndex)
      case 11: try decoder.decodeSingularBoolField(value: &self.isTuple)
      case 12: try decoder.decodeSingularBoolField(value: &self.isConstant)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 2)
    }
    if self.isThreadLocal != false {
      try visitor.visitSingularBoolField(value: self.isThreadLocal, fieldNumber: 3)
    }
    if self.isEntryComputationParameter != false {
      try visitor.visitSingularBoolField(value: self.isEntryComputationParameter, fieldNumber: 5)
    }
    if self.parameterNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.parameterNumber, fieldNumber: 6)
    }
    if self.maybeLiveOut != false {
      try visitor.visitSingularBoolField(value: self.maybeLiveOut, fieldNumber: 7)
    }
    if self.color != 0 {
      try visitor.visitSingularInt64Field(value: self.color, fieldNumber: 8)
    }
    if !self.assigned.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assigned, fieldNumber: 9)
    }
    if !self.parameterShapeIndex.isEmpty {
      try visitor.visitPackedInt64Field(value: self.parameterShapeIndex, fieldNumber: 10)
    }
    if self.isTuple != false {
      try visitor.visitSingularBoolField(value: self.isTuple, fieldNumber: 11)
    }
    if self.isConstant != false {
      try visitor.visitSingularBoolField(value: self.isConstant, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_BufferAllocationProto, rhs: Xla_BufferAllocationProto) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.size != rhs.size {return false}
    if lhs.isThreadLocal != rhs.isThreadLocal {return false}
    if lhs.isTuple != rhs.isTuple {return false}
    if lhs.isEntryComputationParameter != rhs.isEntryComputationParameter {return false}
    if lhs.isConstant != rhs.isConstant {return false}
    if lhs.parameterNumber != rhs.parameterNumber {return false}
    if lhs.parameterShapeIndex != rhs.parameterShapeIndex {return false}
    if lhs.maybeLiveOut != rhs.maybeLiveOut {return false}
    if lhs.color != rhs.color {return false}
    if lhs.assigned != rhs.assigned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_BufferAllocationProto.Assigned: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_BufferAllocationProto.protoMessageName + ".Assigned"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "logical_buffer_id"),
    2: .same(proto: "offset"),
    3: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.logicalBufferID)
      case 2: try decoder.decodeSingularInt64Field(value: &self.offset)
      case 3: try decoder.decodeSingularInt64Field(value: &self.size)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.logicalBufferID != 0 {
      try visitor.visitSingularInt64Field(value: self.logicalBufferID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_BufferAllocationProto.Assigned, rhs: Xla_BufferAllocationProto.Assigned) -> Bool {
    if lhs.logicalBufferID != rhs.logicalBufferID {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HeapSimulatorTrace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HeapSimulatorTrace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .standard(proto: "whole_module_simulation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.events)
      case 2: try decoder.decodeSingularBoolField(value: &self.wholeModuleSimulation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    if self.wholeModuleSimulation != false {
      try visitor.visitSingularBoolField(value: self.wholeModuleSimulation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HeapSimulatorTrace, rhs: Xla_HeapSimulatorTrace) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.wholeModuleSimulation != rhs.wholeModuleSimulation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HeapSimulatorTrace.Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_HeapSimulatorTrace.protoMessageName + ".Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .standard(proto: "buffer_id"),
    3: .standard(proto: "computation_name"),
    4: .standard(proto: "instruction_name"),
    5: .standard(proto: "share_with_canonical_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.kind)
      case 2: try decoder.decodeSingularInt64Field(value: &self.bufferID)
      case 3: try decoder.decodeSingularStringField(value: &self.computationName)
      case 4: try decoder.decodeSingularStringField(value: &self.instructionName)
      case 5: try decoder.decodeSingularInt64Field(value: &self.shareWithCanonicalID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .alloc {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if self.bufferID != 0 {
      try visitor.visitSingularInt64Field(value: self.bufferID, fieldNumber: 2)
    }
    if !self.computationName.isEmpty {
      try visitor.visitSingularStringField(value: self.computationName, fieldNumber: 3)
    }
    if !self.instructionName.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionName, fieldNumber: 4)
    }
    if self.shareWithCanonicalID != 0 {
      try visitor.visitSingularInt64Field(value: self.shareWithCanonicalID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HeapSimulatorTrace.Event, rhs: Xla_HeapSimulatorTrace.Event) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.bufferID != rhs.bufferID {return false}
    if lhs.computationName != rhs.computationName {return false}
    if lhs.instructionName != rhs.instructionName {return false}
    if lhs.shareWithCanonicalID != rhs.shareWithCanonicalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HeapSimulatorTrace.Event.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOC"),
    1: .same(proto: "FREE"),
    2: .same(proto: "SHARE_WITH"),
  ]
}

extension Xla_HloModuleGroupProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloModuleGroupProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "hlo_modules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.hloModules)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.hloModules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hloModules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HloModuleGroupProto, rhs: Xla_HloModuleGroupProto) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.hloModules != rhs.hloModules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_BufferAssignmentProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BufferAssignmentProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "logical_buffers"),
    2: .standard(proto: "buffer_aliases"),
    3: .standard(proto: "buffer_allocations"),
    4: .standard(proto: "heap_simulator_traces"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.logicalBuffers)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.bufferAliases)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.bufferAllocations)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.heapSimulatorTraces)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logicalBuffers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logicalBuffers, fieldNumber: 1)
    }
    if !self.bufferAliases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bufferAliases, fieldNumber: 2)
    }
    if !self.bufferAllocations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bufferAllocations, fieldNumber: 3)
    }
    if !self.heapSimulatorTraces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.heapSimulatorTraces, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_BufferAssignmentProto, rhs: Xla_BufferAssignmentProto) -> Bool {
    if lhs.logicalBuffers != rhs.logicalBuffers {return false}
    if lhs.bufferAliases != rhs.bufferAliases {return false}
    if lhs.bufferAllocations != rhs.bufferAllocations {return false}
    if lhs.heapSimulatorTraces != rhs.heapSimulatorTraces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_BufferAssignmentProto.BufferAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_BufferAssignmentProto.protoMessageName + ".BufferAlias"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_buffer_id"),
    2: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _sourceBufferID: Int64 = 0
    var _location: Xla_LogicalBufferProto.Location? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sourceBufferID = source._sourceBufferID
      _location = source._location
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._sourceBufferID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._location)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._sourceBufferID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._sourceBufferID, fieldNumber: 1)
      }
      if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_BufferAssignmentProto.BufferAlias, rhs: Xla_BufferAssignmentProto.BufferAlias) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sourceBufferID != rhs_storage._sourceBufferID {return false}
        if _storage._location != rhs_storage._location {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HloProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hlo_module"),
    3: .standard(proto: "buffer_assignment"),
  ]

  fileprivate class _StorageClass {
    var _hloModule: Xla_HloModuleProto? = nil
    var _bufferAssignment: Xla_BufferAssignmentProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hloModule = source._hloModule
      _bufferAssignment = source._bufferAssignment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._hloModule)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._bufferAssignment)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._hloModule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._bufferAssignment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HloProto, rhs: Xla_HloProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hloModule != rhs_storage._hloModule {return false}
        if _storage._bufferAssignment != rhs_storage._bufferAssignment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xla_HloSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloSnapshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hlo"),
    2: .same(proto: "arguments"),
    3: .same(proto: "result"),
    4: .standard(proto: "execution_platform"),
  ]

  fileprivate class _StorageClass {
    var _hlo: Xla_HloProto? = nil
    var _arguments: [Xla_LiteralProto] = []
    var _result: Xla_LiteralProto? = nil
    var _executionPlatform: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hlo = source._hlo
      _arguments = source._arguments
      _result = source._result
      _executionPlatform = source._executionPlatform
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._hlo)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._arguments)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._result)
        case 4: try decoder.decodeSingularStringField(value: &_storage._executionPlatform)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._hlo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arguments, fieldNumber: 2)
      }
      if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._executionPlatform.isEmpty {
        try visitor.visitSingularStringField(value: _storage._executionPlatform, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xla_HloSnapshot, rhs: Xla_HloSnapshot) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hlo != rhs_storage._hlo {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._executionPlatform != rhs_storage._executionPlatform {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
